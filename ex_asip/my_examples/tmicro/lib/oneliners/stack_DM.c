
// File generated by noodle version O-2018.09#f5599cac26#190121, Tue May 28 10:41:29 2024
// Copyright 2014-2018 Synopsys, Inc. All rights reserved.
// noodle -Pc -B -Iisg +wisg -Iruntime/include -D__tct_patch__=300 -D__chess__ -D__programmers_view__ tmicro

// File: stack_DM.c
// Stack frame 0 : memory DM stack pointer SP

#ifndef M // arbitrary value, adapt at will
#define M 17
#endif
#ifndef N // arbitrary value < M, adapt at will
#define N 13
#endif

extern "C" {

// Test stack allocation and address generation (for use in normal pointer operations)
// (Return address will point to deallocated space, but remains valid when not dereferenced)
// (Type of object is irrelevant, but must be allocatable, so using the primitive type)

void chess_storage(DM) * stack_address_DM()
{
    tmicro_primitive::word o[M];
    return &o[N];
}

void chess_storage(DM) * stack_address_pI_DM(int i)
{
    tmicro_primitive::word o[M];
    return &o[N+i];
}

void chess_storage(DM) * stack_address_mI_DM(int i)
{
    tmicro_primitive::word o[M];
    return &o[N-i];
}

// Test direct stack load/store
// (Volatile avoids that these over-simplified tests would be optimised away:
//  - a uninitialized stack load results in an undefined value;
//  - a stand-alone stack store is dead code;
//  - a combined stack store and load, is redundant code.)

//-- int                        // size=1 alignment=1

int stack_load___sint_DM() { volatile int o[M]; return o[N]; }
void stack_store___sint_DM(int a) { volatile int o[M]; o[N] = a; }
int stack_st_ld___sint_DM(int a) { volatile int o[M]; o[N] = a; return o[N]; }

//-- unsigned                   // size=1 alignment=1

unsigned stack_load___uint_DM() { volatile unsigned o[M]; return o[N]; }
void stack_store___uint_DM(unsigned a) { volatile unsigned o[M]; o[N] = a; }
unsigned stack_st_ld___uint_DM(unsigned a) { volatile unsigned o[M]; o[N] = a; return o[N]; }

//-- long                       // size=2 alignment=1

long stack_load___slong_DM() { volatile long o[M]; return o[N]; }
void stack_store___slong_DM(long a) { volatile long o[M]; o[N] = a; }
long stack_st_ld___slong_DM(long a) { volatile long o[M]; o[N] = a; return o[N]; }

//-- unsigned long              // size=2 alignment=1

unsigned long stack_load___ulong_DM() { volatile unsigned long o[M]; return o[N]; }
void stack_store___ulong_DM(unsigned long a) { volatile unsigned long o[M]; o[N] = a; }
unsigned long stack_st_ld___ulong_DM(unsigned long a) { volatile unsigned long o[M]; o[N] = a; return o[N]; }

//-- long long                  // size=4 alignment=1

long long stack_load___slonglong_DM() { volatile long long o[M]; return o[N]; }
void stack_store___slonglong_DM(long long a) { volatile long long o[M]; o[N] = a; }
long long stack_st_ld___slonglong_DM(long long a) { volatile long long o[M]; o[N] = a; return o[N]; }

//-- unsigned long long         // size=4 alignment=1

unsigned long long stack_load___ulonglong_DM() { volatile unsigned long long o[M]; return o[N]; }
void stack_store___ulonglong_DM(unsigned long long a) { volatile unsigned long long o[M]; o[N] = a; }
unsigned long long stack_st_ld___ulonglong_DM(unsigned long long a) { volatile unsigned long long o[M]; o[N] = a; return o[N]; }

//-- void *                     // size=1 alignment=1

void * stack_load___Pvoid_DM() { void * volatile o[M]; return o[N]; }
void stack_store___Pvoid_DM(void * a) { void * volatile o[M]; o[N] = a; }
void * stack_st_ld___Pvoid_DM(void * a) { void * volatile o[M]; o[N] = a; return o[N]; }


} //extern "C"  (24 functions)
