Introduction
============
Risk can be used to generate SystemVerilog classes for random instruction
generation. These classes can be used directly in a SystemVerilog main program,
or in an UVM environment.


To run Risk to generate the SystemVerilog classes:

> risk -I ../../lib -u tmicro

This generates a file "tmicro-classes.sv".


To generate instructions based on the SystemVerilog classes only, this directory
contains a main program in "main.sv". Compile and run with:

> vcs -sverilog main.sv
> simv

This generates a file "risk_tmicro_sv.ras".


To generate instructions based on the UVM wrapper classes, this directory
contains the following files:
- test.sv : main program
- instruction.sv : small wrapper around tmicro.sv containing UVM directives
- sequencer.sv : sequencer
- driver.sv : driver
- user_test_sequences.sv : file that includes all test sequences you want to
  generate
- user_arith_test_sequence.sv : example that generates register moves and
  arithmetic instructions

Compile and run with:

> vcs -sverilog -ntb_opts uvm-1.1 test.sv
> simv

This generates a file "risk_tmicro_uvm.ras".


The generated ".ras" files are similar to those that can be generated by Risk
itself (containing bit-strings). For simulation, they first have to be assembled
with Darts:

> darts -E risk_tmicro_uvm.ras -I../../lib tmicro

The result can be disassembled again to see the generated instructions in
assembly format:

> darts -d risk_tmicro_uvm.ras.x -I../../lib tmicro


Details on the generated classes
================================
Risk generates a SystemVerilog class for each of the following nML constructs:
- OR-rules
- AND-rules
- Enumerators
- Constants (immediates)

The name of each class is prepended by "<processor>$". For constants, the name
of the data type is used instead of the name of the nML 'cst'.

For enumerators, different classes may be generated, namely one for each
AND-rule where the enumerator is used in a switch statement that does not contain
all values of the enumerators.


OR-rules
--------
Each class corresponding to an OR-rule contains a "rand enum {S$subrule_1, ...}
sub" field that indicates the sub-rule that is chosen when randomizing this
OR-rule. The values are named "S$<subrule-name>". So, this "sub" field can be
used to impose constraints on the sub-rules that will be generated.

The class also contains handles to the sub-rules themselves. These are named
named "R$<subrule-name>", and can be used to impose further constraints on the
sub-rules.

For example, the tmicro$alu_instr class looks as follows:

  class tmicro$alu_instr;
      rand enum {
         S$alu_rrr,
         ...
      } sub;
      rand tmicro$alu_rrr R$alu_rrr;
      ...
  endclass

Assuming that "x" refers to an instance of this class, a constraint to select the first
sub-rule and impose further constraints on it could look like:

  (x.sub == tmicro$alu_instr::S$alu_rrr) &&
  (x.R$alu_rrr.<constraint>)


AND-rules
---------
Each class corresponding to an AND-rule contains handles to all its nML
parameters. The handles are named "P$<param>", and can be used to impose
contraints on the parameters.

For example, the tmicro$alu_rrr class looks as follows:

  class tmicro$alu_rrr;
      rand tmicro$alu_op$0 P$op;
      rand tmicro$rt P$t;
      rand tmicro$rr P$r;
      rand tmicro$rs P$s;
      ...
  endclass

The first parameter is named "P$op" and refers to an enumerator class
"tmicro$alu_op$0". The latter only contains the enum values that are actually
used in this AND-rule.

If we want to refine the above constraint to certain values of the "P$op"
parameter, that could be done as follows:

  (x.sub == tmicro$alu_instr::S$alu_rrr) &&
  (x.R$alu_rrr.P$op.<constraint>)


Enumerators
-----------
Each class corresponding to an nML enumerator contains a "rand enum {...} val",
with values corresponding to the nML enum values. The value names are prepended
by "E$".

For example, the tmicro$alu_op$0 class looks as follows:

  class tmicro$alu_op$0;
      rand enum {
          E$add = 0,
          ...
      } val;
    ...
  endclass

The above constraint can now be completed to select a specific value:

  (x.sub == tmicro$alu_instr::S$alu_rrr) &&
  (x.R$alu_rrr.P$op.val == tmicro$alu_op$0::E$add)


Constants
---------
Each class corresponding to an nML constant contains a value "rand longint val"
that can be randomized, and default constraints to impose the range of the data
type. The class is actually named after the nML data-type instead of the "cst".

For example, for the following constant:

  cst c3u<uint3>;

the following class is generated:

  class tmicro$uint3;
      rand longint val;
      constraint c {
          0 <= val;
          val <= 7;
      }
      ...
  endclass

The above constraint can e.g. be extended to limit the destination register
to R0..R3:

  (x.sub == tmicro$alu_instr::S$alu_rrr) &&
  (x.R$alu_rrr.P$op.val == tmicro$alu_op$0::E$add) &&
  (x.R$alu_rrr.P$t.P$r.val inside {[0:3]})


Specifying complete instructions
================================

The above examples started from a variable "x" being an instance of the
"tmicro$alu_instr" class. In practice, instructions always have to be specified
starting from the nML start rule. This start rule is named after the processor
name itself, e.g., "tmicro$tmicro".

For example, this is a complete constraint starting from the start rule:

  rand tmicro$tmicro example;
  constraint c {
      (example.sub == tmicro$tmicro::S$alu_instr) &&
      (example.R$alu_instr.sub == tmicro$alu_instr::S$alu_rrr) &&
      (example.R$alu_instr.R$alu_rrr.P$op.val == tmicro$alu_op$0::E$add) &&
      (example.R$alu_instr.R$alu_rrr.P$t.P$r.val inside {[0:3]});
  }


In an UVM context, an extra wrapper class around the start rule class is used.
This wrapper class is called "instruction" and contains some UVM directives, as
well as a field "instr" that refer to the start rule.

So, the same constraint in an UVM context looks as follows:

  instruction example;
  `uvm_do_with(example, {
      (example.instr.sub == tmicro$tmicro::S$alu_instr) &&
      (example.instr.R$alu_instr.sub == tmicro$alu_instr::S$alu_rrr) &&
      (example.instr.R$alu_instr.R$alu_rrr.P$op.val == tmicro$alu_op$0::E$add) &&
      (example.instr.R$alu_instr.R$alu_rrr.P$t.P$r.val inside {[0:3]});
  });
