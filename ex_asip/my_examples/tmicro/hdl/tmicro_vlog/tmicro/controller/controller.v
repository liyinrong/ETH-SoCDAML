
// File generated by Go version O-2018.09#f5599cac26#190121, Tue May 28 10:45:21 2024
// Copyright 2014-2018 Synopsys, Inc. All rights reserved.
// go -B -I../lib -F -D__tct_patch__=300 -Verilog -otmicro_vlog -cgo_options.cfg -Itmicro_vlog/tmp_pdg -updg -updg_controller tmicro



`timescale 1ns/1ps

// module controller : controller
module controller
  ( input                   reset,
    input                   clock,
    input             [2:0] bin_selector_E1,
    input             [2:0] bin_selector_ID,
    input                   die1_in, // bool
    input                   diid_in, // bool
    input                   ier_in, // uint1
    input             [7:0] imr_in, // ubyte
    input             [7:0] ireq_pcu_inp_in, // ubyte
    input                   issue_sig_in,
    input                   jc_in, // bool
    input                   jcr_in, // bool
    input            [15:0] lcr_in, // addr
    input            [15:0] ler_in, // addr
    input             [1:0] lfra_in, // uint2
    input            [15:0] lsr_in, // addr
    input                   mw_stall_in,
    input                   ocd_dis_int_in, // uint1
    input                   ocd_exe_in, // uint1
    input            [15:0] ocd_instr_r_in, // iword
    input                   ocd_req_in, // uint1
    input      signed [7:0] offs_in, // sbyte
    input            [15:0] pcr_in, // addr
    input            [15:0] pm_read_in, // iword
    input                   tcc_in, // bool
    input            [15:0] trgt_in, // addr
    output reg        [1:0] LC_lcr_cntrl_nxtpc_pdg_r_a_out, // uint2
    output reg              LC_lcr_cntrl_nxtpc_pdg_r_en_out, // std_logic
    output reg              LC_lcw_cntrl_nxtpc_pdg_en_out, // std_logic
    output reg        [1:0] LC_lcw_cntrl_nxtpc_pdg_w_a_out, // uint2
    output reg        [1:0] LE_ler_cntrl_nxtpc_pdg_r_a_out, // uint2
    output reg              LE_ler_cntrl_nxtpc_pdg_r_en_out, // std_logic
    output reg              LF_lfw_cntrl_nxtpc_pdg_en_out, // std_logic
    output reg        [1:0] LS_lsr_cntrl_nxtpc_pdg_r_a_out, // uint2
    output reg              LS_lsr_cntrl_nxtpc_pdg_r_en_out, // std_logic
    output reg              PC_pcw_cntrl_nxtpc_pdg_en_out, // std_logic
    output reg              debug_out_out, // uint1
    output reg              halted_out_out, // uint1
    output reg        [7:0] iack_pcu_out_out, // ubyte
    output reg              kill_ID_out,
    output reg       [15:0] lcw_out, // addr
    output reg        [1:0] lfw_out, // uint2
    output reg       [15:0] lnk_if_out, // addr
    output reg       [15:0] lnk_pf_out, // addr
    output reg              mcw_kill_out,
    output reg       [15:0] pcw_out, // addr
    output reg       [15:0] pm_addr_out, // addr
    output reg              pm_ld_pdg_en_out, // std_logic
    output                  proc_stall_out,
    output reg       [15:0] trace_data_out, // addr
    output reg              trace_data_valid_out, // uint1
    output reg              trn_ID_valid_out,
    output reg       [15:0] trn_IR_ID_out
  );


  wire en_lnk_pf_bsr_trgt_E1;
  wire en_vd_hwdo_lcw_lew_E1;
  wire en_vd_jump_trgt_E1;
  wire en_vd_jump_tcc_trgt_E1;
  wire en_vd_jump_tcc_offs_E1;
  wire en_vd_ret_trgt_E1;
  wire en_lnk_pf_bsr_trgt_ID;
  wire en_lnk_if_jti_trgt_ID;
  wire en_vd_halt_ID;
  wire en_vd_jump_trgt_ID;
  wire en_vd_jump_offs_ID;
  wire en_vd_rti_trgt_ID;

  wire en_jump_offs_sig;
  wire en_jump_trgt_sig;

  assign en_lnk_pf_bsr_trgt_E1 = bin_selector_E1 == 3'b001;
  assign en_vd_hwdo_lcw_lew_E1 = bin_selector_E1 == 3'b010;
  assign en_vd_jump_trgt_E1 = bin_selector_E1 == 3'b011;
  assign en_vd_jump_tcc_trgt_E1 = bin_selector_E1 == 3'b100;
  assign en_vd_jump_tcc_offs_E1 = bin_selector_E1 == 3'b101;
  assign en_vd_ret_trgt_E1 = bin_selector_E1 == 3'b110;
  assign en_lnk_pf_bsr_trgt_ID = bin_selector_ID == 3'b001;
  assign en_lnk_if_jti_trgt_ID = bin_selector_ID == 3'b010;
  assign en_vd_halt_ID = bin_selector_ID == 3'b011;
  assign en_vd_jump_trgt_ID = bin_selector_ID == 3'b100;
  assign en_vd_jump_offs_ID = bin_selector_ID == 3'b101;
  assign en_vd_rti_trgt_ID = bin_selector_ID == 3'b110;

  assign en_jump_offs_sig = en_vd_jump_offs_ID || (en_vd_jump_tcc_offs_E1 && tcc_in);
  assign en_jump_trgt_sig = en_lnk_pf_bsr_trgt_ID || en_lnk_pf_bsr_trgt_E1 || en_vd_jump_trgt_ID || en_vd_jump_trgt_E1 || (en_vd_jump_tcc_trgt_E1 && tcc_in) || en_vd_ret_trgt_E1 || en_lnk_if_jti_trgt_ID || en_vd_rti_trgt_ID;

  assign proc_stall_out = 1'b0;

  // File generated by pdg version O-2018.09#f5599cac26#190121, Tue May 28 10:45:21 2024
  // Copyright 2014-2018 Synopsys, Inc. All rights reserved.
  // pdg -B -I../lib -I../lib/isg -D__go__ -pcu -Verilog -cgo_options.cfg -D__tct_patch__=300 +wtmicro_vlog/tmp_pdg tmicro


  // Storages local to the pcu
  reg               reg_booting;
  reg               pdg_update_reg_booting;
  reg               pdg_we_reg_booting;
  reg               reg_debug_mode;
  reg               pdg_update_reg_debug_mode;
  reg               pdg_we_reg_debug_mode;
  reg        [15:0] reg_f_instr;
  reg        [15:0] pdg_update_reg_f_instr;
  reg               pdg_we_reg_f_instr;
  reg               reg_fetch;
  reg               pdg_update_reg_fetch;
  reg               pdg_we_reg_fetch;
  reg               reg_halted;
  reg               pdg_update_reg_halted;
  reg               pdg_we_reg_halted;
  reg               debug_mode;
  reg               trn_interrupted;

  // user_issue
  always @ (*)
  begin : p_user_issue
    reg               trn_interrupted_var;
    reg               debug_mode_var;
    reg        [15:0] f_instr;
    reg               jcr_taken;
    reg               jc_taken;
    reg               issue_ins;
    reg               interruptible;
    reg         [3:0] i_vector;
    reg         [7:0] i_ack;
    reg               check_interrupts_result;
    reg         [7:0] i_mask;
    reg         [7:0] mreq;
    reg               stop_issue;
    reg        [15:0] pdg_encoding_swi_result;
    reg        [15:0] swi_instr;

    trn_ID_valid_out = 0;
    trn_IR_ID_out = 0;
    kill_ID_out = 1'b0;
    mcw_kill_out = 1'b0;
    debug_mode = 0;
    debug_out_out = 0;
    halted_out_out = 0;
    iack_pcu_out_out = 0;
    trace_data_valid_out = 0;
    trn_interrupted = 0;

    check_interrupts_result = 0;
    i_mask = 0;
    mreq = 0;
    pdg_encoding_swi_result = 0;
    swi_instr = 0;

    pdg_we_reg_debug_mode = 1'b0;
    pdg_update_reg_debug_mode = 0;
    pdg_we_reg_f_instr = 1'b0;
    pdg_update_reg_f_instr = 0;

    f_instr = reg_f_instr;
    jcr_taken = jcr_in && tcc_in;
    jc_taken = jc_in && tcc_in;
    issue_ins = issue_sig_in && !jcr_taken && !jc_taken;
    if (reg_fetch)
    begin
      f_instr = pm_read_in;
    end
    interruptible = issue_ins && diid_in == 1'b0 && die1_in == 1'b0;
    debug_mode_var = ocd_req_in && interruptible;
    i_vector = 4'b0000;
    i_ack = 8'b00000000;
    trn_interrupted_var = 1'b0;
    if (interruptible && !ocd_dis_int_in && !debug_mode_var && ier_in == 1'b1)
    begin
      i_mask = imr_in;
      mreq = ireq_pcu_inp_in & i_mask;
      if (ireq_pcu_inp_in[0])
      begin
        i_vector = 4'b0000;
        i_ack = 8'b00000001;
        check_interrupts_result = 1'b1;
      end
      else
      begin
        if (mreq[1])
        begin
          i_vector = 4'b0010;
          i_ack = 8'b00000010;
          check_interrupts_result = 1'b1;
        end
        else
        begin
          if (mreq[2])
          begin
            i_vector = 4'b0100;
            i_ack = 8'b00000100;
            check_interrupts_result = 1'b1;
          end
          else
          begin
            if (mreq[3])
            begin
              i_vector = 4'b0110;
              i_ack = 8'b00001000;
              check_interrupts_result = 1'b1;
            end
            else
            begin
              if (mreq[4])
              begin
                i_vector = 4'b1000;
                i_ack = 8'b00010000;
                check_interrupts_result = 1'b1;
              end
              else
              begin
                if (mreq[5])
                begin
                  i_vector = 4'b1010;
                  i_ack = 8'b00100000;
                  check_interrupts_result = 1'b1;
                end
                else
                begin
                  if (mreq[6])
                  begin
                    i_vector = 4'b1100;
                    i_ack = 8'b01000000;
                    check_interrupts_result = 1'b1;
                  end
                  else
                  begin
                    if (mreq[7])
                    begin
                      i_vector = 4'b1110;
                      i_ack = 8'b10000000;
                      check_interrupts_result = 1'b1;
                    end
                    else
                    begin
                      check_interrupts_result = 1'b0;
                    end
                  end
                end
              end
            end
          end
        end
      end
      trn_interrupted_var = check_interrupts_result;
    end
    stop_issue = reg_booting || reg_halted || debug_mode_var || reg_debug_mode;
    if (jcr_taken)
    begin
      mcw_kill_out = 1;
      kill_ID_out = 1;
    end
    trace_data_valid_out = 1'b0;
    if (trn_interrupted_var)
    begin
      pdg_encoding_swi_result = {12'b001011100111 , i_vector};
      swi_instr = pdg_encoding_swi_result;
      trace_data_valid_out = 1'b1;
      trn_ID_valid_out = 1;
      trn_IR_ID_out = swi_instr;
    end
    else
    begin
      if (ocd_exe_in)
      begin
        trn_ID_valid_out = 1;
        trn_IR_ID_out = ocd_instr_r_in;
      end
      else
      begin
        if (mw_stall_in)
        begin
          trn_ID_valid_out = 0;
          trn_IR_ID_out = f_instr;
        end
        else
        begin
          if (issue_ins && !stop_issue)
          begin
            trace_data_valid_out = 1'b1;
            trn_ID_valid_out = 1;
            trn_IR_ID_out = f_instr;
          end
        end
      end
    end
    halted_out_out = reg_halted;
    debug_out_out = reg_debug_mode;
    iack_pcu_out_out = i_ack;
    pdg_we_reg_debug_mode = 1'b1;
    pdg_update_reg_debug_mode = debug_mode_var;
    pdg_we_reg_f_instr = 1'b1;
    pdg_update_reg_f_instr = f_instr;
    debug_mode = debug_mode_var;
    trn_interrupted = trn_interrupted_var;
  end //p_user_issue


  // user_next_pc
  always @ (*)
  begin : p_user_next_pc
    reg               lp_jump;
    reg               lp_done;
    reg               lp_update;
    reg        [15:0] tlcr;
    reg        [15:0] tlsr;
    reg        [15:0] tler;
    reg               new_fetch;
    reg        [15:0] nextpc;
    reg signed  [7:0] t_offs;
    reg               new_fetch_0;
    reg               advance_pc;

    LC_lcr_cntrl_nxtpc_pdg_r_a_out = 0;
    LC_lcr_cntrl_nxtpc_pdg_r_en_out = 0;
    LC_lcw_cntrl_nxtpc_pdg_en_out = 0;
    LC_lcw_cntrl_nxtpc_pdg_w_a_out = 0;
    LE_ler_cntrl_nxtpc_pdg_r_a_out = 0;
    LE_ler_cntrl_nxtpc_pdg_r_en_out = 0;
    LF_lfw_cntrl_nxtpc_pdg_en_out = 0;
    LS_lsr_cntrl_nxtpc_pdg_r_a_out = 0;
    LS_lsr_cntrl_nxtpc_pdg_r_en_out = 0;
    PC_pcw_cntrl_nxtpc_pdg_en_out = 0;
    lcw_out = 0;
    lfw_out = 0;
    lnk_if_out = 0;
    lnk_pf_out = 0;
    pcw_out = 0;
    pm_addr_out = 0;
    pm_ld_pdg_en_out = 0;
    trace_data_out = 0;

    t_offs = 0;
    new_fetch_0 = 0;
    advance_pc = 0;

    pdg_we_reg_booting = 1'b0;
    pdg_update_reg_booting = 0;
    pdg_we_reg_fetch = 1'b0;
    pdg_update_reg_fetch = 0;
    pdg_we_reg_halted = 1'b0;
    pdg_update_reg_halted = 0;

    lnk_if_out = pcr_in;
    lnk_pf_out = pcr_in + 16'b0000000000000001;
    lp_jump = 1'b0;
    lp_done = 1'b0;
    lp_update = 1'b0;
    tlcr = 16'b0000000000000000;
    tlsr = 16'b0000000000000000;
    tler = 16'b0000000000000000;
    if (lfra_in < 2'b11)
    begin
      LC_lcr_cntrl_nxtpc_pdg_r_en_out = 1'b1;
      LC_lcr_cntrl_nxtpc_pdg_r_a_out = lfra_in;
      tlcr = lcr_in;
      LS_lsr_cntrl_nxtpc_pdg_r_en_out = 1'b1;
      LS_lsr_cntrl_nxtpc_pdg_r_a_out = lfra_in;
      tlsr = lsr_in;
      LE_ler_cntrl_nxtpc_pdg_r_en_out = 1'b1;
      LE_ler_cntrl_nxtpc_pdg_r_a_out = lfra_in;
      tler = ler_in;
      if (pcr_in == tler)
      begin
        if (tlcr == 16'b0000000000000001)
        begin
          lp_done = 1'b1;
        end
        else
        begin
          lp_jump = 1'b1;
        end
      end
    end
    new_fetch = !(trn_interrupted || reg_halted || debug_mode);
    nextpc = pcr_in;
    if (en_jump_offs_sig)
    begin
      t_offs = offs_in;
      nextpc = pcr_in + {{8{t_offs[7]}}, t_offs};
    end
    else
    begin
      if (en_jump_trgt_sig)
      begin
        nextpc = trgt_in;
      end
      else
      begin
        new_fetch_0 = new_fetch;
        new_fetch = new_fetch_0 & (issue_sig_in || mw_stall_in);
        advance_pc = new_fetch && !(reg_booting || reg_debug_mode);
        if (advance_pc)
        begin
          lp_update = 1'b1;
          if (lp_jump)
          begin
            nextpc = tlsr;
          end
          else
          begin
            nextpc = pcr_in + 16'b0000000000000001;
          end
        end
      end
    end
    if (lp_update)
    begin
      if (lp_jump)
      begin
        LC_lcw_cntrl_nxtpc_pdg_w_a_out = lfra_in;
        LC_lcw_cntrl_nxtpc_pdg_en_out = 1'b1;
        lcw_out = tlcr - 16'b0000000000000001;
      end
      if (lp_done)
      begin
        LF_lfw_cntrl_nxtpc_pdg_en_out = 1'b1;
        lfw_out = lfra_in - 2'b01;
      end
    end
    if (new_fetch)
    begin
      pm_addr_out = nextpc;
      pm_ld_pdg_en_out = 1'b1;
    end
    PC_pcw_cntrl_nxtpc_pdg_en_out = 1'b1;
    pcw_out = nextpc;
    pdg_we_reg_fetch = 1'b1;
    pdg_update_reg_fetch = new_fetch;
    pdg_we_reg_booting = 1'b1;
    pdg_update_reg_booting = 1'b0;
    if (en_vd_halt_ID)
    begin
      pdg_we_reg_halted = 1'b1;
      pdg_update_reg_halted = 1'b1;
    end
    else
    begin
      if (trn_interrupted)
      begin
        pdg_we_reg_halted = 1'b1;
        pdg_update_reg_halted = 1'b0;
      end
    end
    trace_data_out = pcr_in;
  end //p_user_next_pc


  always @ (posedge clock or posedge reset)
  begin : p_update_status
    if (reset)
    begin
      reg_booting <= 1'b1;
      reg_debug_mode <= 1'b0;
      reg_f_instr <= 16'b0000000000000000;
      reg_fetch <= 1'b0;
      reg_halted <= 1'b0;
    end
    else
    begin
      if (pdg_we_reg_booting)
        reg_booting <= pdg_update_reg_booting;
      if (pdg_we_reg_debug_mode)
        reg_debug_mode <= pdg_update_reg_debug_mode;
      if (pdg_we_reg_f_instr)
        reg_f_instr <= pdg_update_reg_f_instr;
      if (pdg_we_reg_fetch)
        reg_fetch <= pdg_update_reg_fetch;
      if (pdg_we_reg_halted)
        reg_halted <= pdg_update_reg_halted;
    end
  end // p_update_status
endmodule
