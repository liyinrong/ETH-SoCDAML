/*
-- File : hazards.n
--
-- Contents : nML model for the Tmicro core - pipeline hazard rules.
--
-- Copyright (c) 2014-2016 Synopsys, Inc. This Synopsys processor model
-- captures an ASIP Designer Design Technique. The model and all associated
-- documentation are proprietary to Synopsys, Inc. and may only be used
-- pursuant to the terms and conditions of a written license agreement with
-- Synopsys, Inc.  All other use, reproduction, modification, or distribution
-- of the Synopsys processor model or the associated  documentation is
-- strictly prohibited.
*/


// Hazards related to end-of-loop checking for zero-overhead loops:

//  A minimum offset is required from a jump instruction to the end-of-loop,
//  such that the jump instruction or any next instruction word still fetched
//  cannot trigger an end-of-loop check before the jump condition is known.
//  The following hazard rules are needed given the tmicro PCU, where the
//  end-of-loop check happens based on the address of the instruction in the IF
//  stage, and is disabled (lp_update==0) when a jump signal is set or when no
//  PM fetch is done (issue_sig()==0 and mword_sig()==0).

//  a jump may not be the end-of-loop instruction, as the end-of-loop check (at
//  IF stage) would then come earlier than the jump action (ID/E1 stage).
sw_stall 1 words class(jump_to_loop_end) () {
    class(jump);
} -> {
    special(end_of_loop);
}

//  before a cycles(3|1) jump executes, the jump and its next instruction have
//  already passed the IF/end-of-loop stage, so a 3 word offset is needed
sw_stall 1..2 words class(jump_to_loop_end) () {
    class(jump), cycles(3|1);
} -> {
    special(end_of_loop);
}

//  before a cycles(3|2) jump executes, the jump and its secondary instruction
//  word already passed the IF/end-of-loop stage, so a 3 word offset is needed
sw_stall 1..2 words class(jump_to_loop_end) () {
    class(jump), cycles(3|2), words(2);
} -> {
    special(end_of_loop);
}

//  after a call (and its delay slots) still an additional instruction is
//  needed (as return address) at the end-of-loop
sw_stall 1..2 words class(bsr_to_loop_end) () {
    stage ID: lnk_pf = bsr(trgt); words(2);
} -> {
    special(end_of_loop);
}
sw_stall 1..3 words class(bsr_to_loop_end) () {
    stage E1: lnk_pf = bsr(trgt); delay_slots(2);
} -> {
    special(end_of_loop);
}

//  two (nested) hardware loops may not end at the same address
sw_stall 0 words class(between_loop_ends) () {
    special(end_of_loop);
} -> {
    special(end_of_loop);
}

//   disallow software breakpoint on end-of-loop instruction
sw_stall 1 instructions () {
    special(pdc_sw_breakpoint);
} -> {
    special(end_of_loop);
}


// When there are 2 delay slots a PM load in the first delay slots conflicts
// with the instruction fetch.

sw_stall 1..2 cycles class(pm_load_conflict) () {
    stage ID..E1: ...`E1` = PM[...`ID`]`ID`;
} -> {
    delay_slots(2), special(delay_slot_end);
}


// The following rules are copied from the hazard report (tmicro_hzrd.rpt)
// generated by animal when using -h option :

//  Structural hazard for cycle offset [1,1] on offs
sw_stall 1 cycles class(offs_conflict) () {
    rsrc(offs `E1`);
}
-> {
    rsrc(offs `ID`);
}

//  Structural hazard for cycle offset [1,1] on dm_addr
sw_stall 1 cycles class(dm_addr_conflict) () {
    rsrc(dm_addr `E1`);
}
-> {
    rsrc(dm_addr `ID`);
}


//  RAW data hazard for cycle offset [1,1] on R
sw_stall 1 cycles <check_at_entry> class(read_after_write_R) () {
    stage E1 : R$[#] = ...;
}
-> {
    stage ID : ... = R$[#];
}

//  RAW data hazard for cycle offset [1,1] on SP {
sw_stall 1 cycles class(read_after_write_SP) () {
    stage E1 : #SP = ...;
}
-> {
    stage ID : ... = #SP;
}

//  RAW data hazard for cycle offset [1,1] on ILR
sw_stall 1 cycles class(read_after_write_ILR) () {
    stage E1 : #ILR = ...;

}
-> {
    stage ID : ... = #ILR;
}
