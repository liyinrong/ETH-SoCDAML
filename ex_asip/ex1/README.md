# Log-in into the account

Reproduce the steps described in the README under the `ex_asip` root directory.

# Exercise 1

Start the tool with `./start_asiptool`

## Documentation

Under doc/ you find plenty symbolic links for documentation. For these exercises
open

- the nml manual (nml-manual.pdf or nml\_processor\_descr\_language.pdf)
- the pdg manual (pdg-manual.pdf or primitive\_def\_gen.pdf)
- the chess_user manual (chess\_user-manual.pdf)

## Processor

In this example, we will use the `tmicro` processor as in the previous example. The
`tmicro` processor implements general-purpose instructions such as 16-bit integer
arithmetic, bitwise logical and compare instructions; load and store
instructions, and various control instructions. In addition to these fixed
features, many optional features such as shift instructions,
multiplication instructions, zero overhead loops, interrupts and on-chip
debugging can be enabled. Please, compile the processor and its `libc` and `C`
library as it has been described in the previous example (if not done yet).

## Application

Copy the folder under `ex1/tmicro/sum_abs_diff` under the processor folder `my_examples/tmicro` that we previously used.
```
File -> Open -> Project
```
You will find 2 projects, compile `sum_abs_diff.prx`.

```
Compile -> Make
```

In the project setting, the CPP preprocessor and linking options that we
discussed in the previous example (`Compile an application`) should already be
set to inherit. Double-check it to proceed.

### Have a look

Get an overview of the processor by having a look at
`my_examples/doc/tmicro_proc.pdf` and have investigate the various files under the
`tmicro/lib` folder.

What is this? Let's have a look!

#### .n files

.n files contain the `nml` description of the microprocessor architecture. Here you
find:

- Instruction Set Architecture Description
- Structural Skeleton of the processor
- Functional Units
- Instructions Executional Behaviours

Open `tmicro.n` where the main features and signals of the core are described,
and use the primitive header file of the core to understand the data types and
functions. The instructions rules are described hierarchically. Can you find the
first rule? Is it an AND or OR rule? Open the `alu.n` to dip into the
instructions rule and to get familiar with the tmicro architecture.

#### .p files

.p files contain the PDG description of the microprocessor functions. Here you
have a PDG function/module for each instruction implemented. For example, have a
look at `tmicro.p`.

#### Generated Hardware

Out of curiosity, you can generate the actual hardware description needed to
form the core by compiling the `tmicro/hdl/tmicro_{vlog,vhdl}.prx` projects.

Have a look at the Verilog or VHDL generated in
`hdl/tmicro_{vlog,vhdl}/tmicro/prim/alu.{v,vhd}` after compiling one of these
projects.

This is the real generated HW!

#### c, h files

Once you compile the processor model, most of the ISS functions are generated in
C++. There are many files, the most important are:

- `lib/isg/<processorname>_iss_types.h` is the native equivalent of `<processorname>.h`
- `lib/isg/<processorname>_inline_primitives.h` is the native equivalent of
  `<processorname>.p`

The native equivalent of the C application layer (`<processorname>_chess.h`) is
generated in the following four files :

- `lib/isg/<processorname>_chess_types.{c,h}` contain the native model of the
  application types and their constructors.
- `lib/isg/<processorname>_chess_opns.{c,h}` contain the native model of the function promotions and inlinings.


#### Disassembled files

Once you compile your application, you can display the assembler generated by
opening

sum_abs_diff/Release/sum_abs_diff.as

### Have fun

Now we have more or less understood where to look at for understanding our
processor. As the title hints, the application is implementing the sum of
the absolute difference between two vectors of length N. Run the application, annotate
the execution time and have a look at the assembly.

- Runtime: 91 cycles

- ASM of my sum_abs_diff function:

```
LOOP BODY:
mvib r4,0x0
ld r5,dm(r1++)
ld r6,dm(r2++)
sub r5,r5,r6
sub r6,r4,r5
lt r5,r4
sel r5,r6,r5
add r0,r0,r5
```

So, the program implements:

```
LOOP BODY:
load from memory A <- *pA, pA++
load from memory B <- *pB, pB++
diff    = A - B;
ndiff   = 0 - diff;
b       = diff < 0;
absdiff = b ? ndiff : diff;
acc     = acc + absdiff;
```

Having a single instruction able to do the absolute value `abs(x)` would mean
having something like:

```
LOOP BODY:
load from memory A <- *pA, pA++
load from memory B <- *pB, pB++
diff    = A - B;
absdiff = abs(diff);
acc     = acc + absdiff;
```

Which is 2 instructions less. In the case of a single-cycle implementation, we would
gain a speedup of 2 clock cycles per loop.

Let's implement it then!

### ABS instruction extension

Now we are going to extend our `tmicro` core with the absolute value extension.

1. First of all, we need to find a free space in the encoding space
2. We need to implement such instruction in the microprocessor model
3. We need to tell the compiler how to use this new instruction so that it can be used when needed

#### Free encoding space

We have to look for the `tmicro` encoding space and find unset patterns to encode
our absolute value instruction. The abs instruction is a single operand
operation, so it needs to encode the op_code for telling the core to do the abs
operation, plus it needs to know the source and destination register addresses.

```
open my_examples/doc/tmicro_proc.pdf and look at chapter 6 for the ISA
Note: 'Instruction groups with prefixes 100, 101, 110 and 111 are available to add extensions to the T MICRO core.'
```

Moreover, to simplify our research of free encoding space, the Chess compiler
tells us what are the free encoding space under:

```
tmicro/lib/isg/tmicro_das_unused_instrs.rpt
```


Let's choose '100' for the instruction group (bit 15-13), '0000' as the operation
group (bit 12-9), the 3 bits for destination register t and source register r at
bit 8-6 and 5-3 as for ALU instructions. The bits 2-0 are not used (don't care).

#### Implement the instruction

To ease the first steps in this exercise, you can copy some prepared files in `ex1/tmicro/lib`
into your project directory.
```
cp ex1/tmicro/lib/* my_examples/tmicro/lib/
```

First, we'll add the extension field (the first 3 bits of the instruction) to
the instruction set grammar defined in `lib/tmicro.n`.

For that, replace the block `opn tmicro` with the following,

```
opn tmicro(alu_instr        |
		   move_instr       |
		   load_store_instr |
		   control_instr    |
		   dma              |
		   ext_instr )
{
	image
		: alu_instr
		| move_instr
		| load_store_instr
		| control_instr
		| dma
		| ext_instr
		;
}
```
which adds `ext_instr` as a valid instruction type.

Next, we will declare our instruction called `ext_abs` in `lib/tmicro.h`.
Uncomment `word ext_abs(word);` to declare an instruction `ext_abs` that takes
one argument of size `word` and returns a `word`-sized result.

The functional behavior of the available instructions is defined in
`lib/tmicro.p`. Uncomment the function `word ext_abs(word a)` in `tmicro.p` to
describe what the new instruction implements.

The new instruction still needs to be added to the processor's ALU. For that, in
`lib/alu.n`, uncomment the `opn ext_abs_r(t: rt, r: rr)` operation declaration
and uncomment the rules for extensions `ext_instr(ext_abs_r)`.

Now we can re-compile the core.

#### Instruct the compiler

Open the `tmicro/lib/tmicro_rewrite.h` file. It contains special source code
patterns that the compiler should map onto processor instructions, such as our
new instruction.

To detect cases where our `ext_abs` operation can be used, uncomment `promotion
int ext_abs_(int) = word ext_abs(word);` and all the rules starting with
`chess_rewrite int ext_abs_rule_*`.

If the compiler sees those patterns, it will map the operation to the `ext_abs`
instructions in the core.

### Compile the ISS

Recompile the libraries (`libc` and `libtmicro`) as well as the ISS (see the
main `README.md` file) to have your changes take effect.

### Compile again your application

Compile the `sum_abs_diff` application again, run it and open the assembler
generated. Have you noticed something different?

- Runtime: 71 cycles

- ASM of my sum_abs_diff function:

```
LOOP BODY:
ld r5,dm(r1++)
ld r6,dm(r2++)
sub r4,r4,r5
ext_abs r4,r4
add r0,r0,r5
```

As expected, we now have 2 instructions less in our loop and 2xN cycles less
over the execution of the program. Our new instruction has been inserted to
implement the absolute value!

### Regenerate the Hardware

Recompile the hardware as explained above.

Have a look at the `HDL` generated in the alu. Something different?

which kind of HW resources did we add?
