
// File generated by noodle version O-2018.09#f5599cac26#190121, Tue May 28 12:03:15 2024
// Copyright 2014-2018 Synopsys, Inc. All rights reserved.
// noodle -ps -B -Iisg +wisg -Iruntime/include -D__tct_patch__=300 -D__checkers__ tzscale

#ifdef __chess__
#error "generated native file not intended for compilation by chess"
#endif

// Primitive types and functions
// used in Checkers ISS and PDG (and possibly native)

#ifndef _tzscale_iss_types_h
#define _tzscale_iss_types_h

#include "chess.h"
#include "vbit.h"

#ifdef CHESS_NATIVE_NAMESPACE
namespace CHESS_NATIVE_NAMESPACE {
#endif

namespace tzscale_primitive {

//  Primitive types (declarations)

class w08;              // property(  8 bit   signed );
class w16;              // property( 16 bit   signed );
class w32;              // property( 32 bit   signed );
class addr;             // property( 32 bit unsigned );
class iword;            // property( 32 bit unsigned );
class uint1;            // property(  1 bit unsigned );
class uint3;            // property(  3 bit unsigned );
class uint4;            // property(  4 bit unsigned );
class uint5;            // property(  5 bit unsigned );
class uint5nz;          // property(  5 bit unsigned min=1 );
class uint6_1_31;       // property(  6 bit unsigned min=1 max=31 );
class uint7s4;          // property(  7 bit unsigned step=4 );
class uint8;            // property(  8 bit unsigned );
class uint8s4;          // property(  8 bit unsigned step=4 );
class uint10nz4;        // property( 10 bit unsigned step=4 min=4 );
class uint12;           // property( 12 bit unsigned );
class uint16;           // property( 16 bit unsigned );
class int3;             // property(  3 bit   signed );
class int5;             // property(  5 bit   signed );
class int6n;            // property(  6 bit   signed max=-1 );
class int6p;            // property(  6 bit   signed min=1 );
class int6;             // property(  6 bit   signed );
class int9s2;           // property(  9 bit   signed step=2 );
class int10ns16;        // property( 10 bit   signed step=16 max=-16 );
class int10ps16;        // property( 10 bit   signed step=16 min=16 max=496 );
class int12;            // property( 12 bit   signed );
class int12s2;          // property( 12 bit   signed step=2 );
class int13s2;          // property( 13 bit   signed step=2 );
class int16;            // property( 16 bit   signed );
class int20;            // property( 20 bit   signed );
class int20p;           // property( 20 bit   signed );
class int21s2;          // property( 21 bit   signed step=2 );
class int26;            // property( 26 bit   signed );
class v4uint1;          // property( vector uint1[4] );
class v4uint8;          // property( vector uint8[4] );


//  Primitive types (definitions)

class w08
{
public:
    typedef VBit<8, true> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    w08() = default;
    template <int B, bool S> w08(const VBit<B, S>& a) : val(a) {}
    w08(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> w08(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    w08(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const w08& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, w08& x) { is >> x.val; return is; }
public:
};
inline const w08::BitType& toBitType(const w08& v) { return v.val; }

class w16
{
public:
    typedef VBit<16, true> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    w16() = default;
    template <int B, bool S> w16(const VBit<B, S>& a) : val(a) {}
    w16(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> w16(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    w16(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const w16& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, w16& x) { is >> x.val; return is; }
public:
};
inline const w16::BitType& toBitType(const w16& v) { return v.val; }

class w32
{
public:
    typedef VBit<32, true> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    w32() = default;
    template <int B, bool S> w32(const VBit<B, S>& a) : val(a) {}
    w32(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> w32(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    w32(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const w32& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, w32& x) { is >> x.val; return is; }
public:
    w32(uint5);
    w32(int6);
    w32(int6p);
    w32(int6n);
    w32(uint6_1_31);
    w32(uint7s4);
    w32(uint8s4);
    w32(int10ns16);
    w32(int10ps16);
    w32(int12);
    w32(uint12);
    w32(uint10nz4);
};
inline const w32::BitType& toBitType(const w32& v) { return v.val; }

class addr
{
public:
    typedef VBit<32, false> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    addr() = default;
    template <int B, bool S> addr(const VBit<B, S>& a) : val(a) {}
    addr(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> addr(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    addr(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const addr& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, addr& x) { is >> x.val; return is; }
public:
    addr(w32);
};
inline const addr::BitType& toBitType(const addr& v) { return v.val; }

class iword
{
public:
    typedef VBit<32, false> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    iword() = default;
    template <int B, bool S> iword(const VBit<B, S>& a) : val(a) {}
    iword(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> iword(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    iword(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const iword& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, iword& x) { is >> x.val; return is; }
public:
};
inline const iword::BitType& toBitType(const iword& v) { return v.val; }

class uint1
{
public:
    typedef VBit<1, false> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    uint1() = default;
    template <int B, bool S> uint1(const VBit<B, S>& a) : val(a) {}
    uint1(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> uint1(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    uint1(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const uint1& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, uint1& x) { is >> x.val; return is; }
public:
};
inline const uint1::BitType& toBitType(const uint1& v) { return v.val; }

class uint3
{
public:
    typedef VBit<3, false> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    uint3() = default;
    template <int B, bool S> uint3(const VBit<B, S>& a) : val(a) {}
    uint3(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> uint3(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    uint3(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const uint3& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, uint3& x) { is >> x.val; return is; }
public:
};
inline const uint3::BitType& toBitType(const uint3& v) { return v.val; }

class uint4
{
public:
    typedef VBit<4, false> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    uint4() = default;
    template <int B, bool S> uint4(const VBit<B, S>& a) : val(a) {}
    uint4(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> uint4(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    uint4(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const uint4& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, uint4& x) { is >> x.val; return is; }
public:
};
inline const uint4::BitType& toBitType(const uint4& v) { return v.val; }

class uint5
{
public:
    typedef VBit<5, false> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    uint5() = default;
    template <int B, bool S> uint5(const VBit<B, S>& a) : val(a) {}
    uint5(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> uint5(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    uint5(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const uint5& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, uint5& x) { is >> x.val; return is; }
public:
    uint5(uint5nz);
};
inline const uint5::BitType& toBitType(const uint5& v) { return v.val; }

class uint5nz
{
public:
    typedef VBit<5, false> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    uint5nz() = default;
    template <int B, bool S> uint5nz(const VBit<B, S>& a) : val(a) {}
    uint5nz(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> uint5nz(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    uint5nz(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const uint5nz& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, uint5nz& x) { is >> x.val; return is; }
public:
};
inline const uint5nz::BitType& toBitType(const uint5nz& v) { return v.val; }

class uint6_1_31
{
public:
    typedef VBit<6, false> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    uint6_1_31() = default;
    template <int B, bool S> uint6_1_31(const VBit<B, S>& a) : val(a) {}
    uint6_1_31(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> uint6_1_31(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    uint6_1_31(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const uint6_1_31& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, uint6_1_31& x) { is >> x.val; return is; }
public:
};
inline const uint6_1_31::BitType& toBitType(const uint6_1_31& v) { return v.val; }

class uint7s4
{
public:
    typedef VBit<7, false> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    uint7s4() = default;
    template <int B, bool S> uint7s4(const VBit<B, S>& a) : val(a) {}
    uint7s4(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> uint7s4(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    uint7s4(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const uint7s4& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, uint7s4& x) { is >> x.val; return is; }
public:
};
inline const uint7s4::BitType& toBitType(const uint7s4& v) { return v.val; }

class uint8
{
public:
    typedef VBit<8, false> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    uint8() = default;
    template <int B, bool S> uint8(const VBit<B, S>& a) : val(a) {}
    uint8(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> uint8(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    uint8(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const uint8& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, uint8& x) { is >> x.val; return is; }
public:
};
inline const uint8::BitType& toBitType(const uint8& v) { return v.val; }

class uint8s4
{
public:
    typedef VBit<8, false> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    uint8s4() = default;
    template <int B, bool S> uint8s4(const VBit<B, S>& a) : val(a) {}
    uint8s4(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> uint8s4(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    uint8s4(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const uint8s4& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, uint8s4& x) { is >> x.val; return is; }
public:
};
inline const uint8s4::BitType& toBitType(const uint8s4& v) { return v.val; }

class uint10nz4
{
public:
    typedef VBit<10, false> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    uint10nz4() = default;
    template <int B, bool S> uint10nz4(const VBit<B, S>& a) : val(a) {}
    uint10nz4(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> uint10nz4(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    uint10nz4(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const uint10nz4& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, uint10nz4& x) { is >> x.val; return is; }
public:
};
inline const uint10nz4::BitType& toBitType(const uint10nz4& v) { return v.val; }

class uint12
{
public:
    typedef VBit<12, false> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    uint12() = default;
    template <int B, bool S> uint12(const VBit<B, S>& a) : val(a) {}
    uint12(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> uint12(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    uint12(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const uint12& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, uint12& x) { is >> x.val; return is; }
public:
};
inline const uint12::BitType& toBitType(const uint12& v) { return v.val; }

class uint16
{
public:
    typedef VBit<16, false> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    uint16() = default;
    template <int B, bool S> uint16(const VBit<B, S>& a) : val(a) {}
    uint16(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> uint16(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    uint16(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const uint16& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, uint16& x) { is >> x.val; return is; }
public:
};
inline const uint16::BitType& toBitType(const uint16& v) { return v.val; }

class int3
{
public:
    typedef VBit<3, true> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    int3() = default;
    template <int B, bool S> int3(const VBit<B, S>& a) : val(a) {}
    int3(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> int3(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    int3(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const int3& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, int3& x) { is >> x.val; return is; }
public:
};
inline const int3::BitType& toBitType(const int3& v) { return v.val; }

class int5
{
public:
    typedef VBit<5, true> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    int5() = default;
    template <int B, bool S> int5(const VBit<B, S>& a) : val(a) {}
    int5(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> int5(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    int5(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const int5& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, int5& x) { is >> x.val; return is; }
public:
};
inline const int5::BitType& toBitType(const int5& v) { return v.val; }

class int6n
{
public:
    typedef VBit<6, true> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    int6n() = default;
    template <int B, bool S> int6n(const VBit<B, S>& a) : val(a) {}
    int6n(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> int6n(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    int6n(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const int6n& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, int6n& x) { is >> x.val; return is; }
public:
};
inline const int6n::BitType& toBitType(const int6n& v) { return v.val; }

class int6p
{
public:
    typedef VBit<6, true> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    int6p() = default;
    template <int B, bool S> int6p(const VBit<B, S>& a) : val(a) {}
    int6p(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> int6p(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    int6p(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const int6p& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, int6p& x) { is >> x.val; return is; }
public:
};
inline const int6p::BitType& toBitType(const int6p& v) { return v.val; }

class int6
{
public:
    typedef VBit<6, true> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    int6() = default;
    template <int B, bool S> int6(const VBit<B, S>& a) : val(a) {}
    int6(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> int6(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    int6(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const int6& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, int6& x) { is >> x.val; return is; }
public:
};
inline const int6::BitType& toBitType(const int6& v) { return v.val; }

class int9s2
{
public:
    typedef VBit<9, true> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    int9s2() = default;
    template <int B, bool S> int9s2(const VBit<B, S>& a) : val(a) {}
    int9s2(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> int9s2(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    int9s2(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const int9s2& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, int9s2& x) { is >> x.val; return is; }
public:
};
inline const int9s2::BitType& toBitType(const int9s2& v) { return v.val; }

class int10ns16
{
public:
    typedef VBit<10, true> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    int10ns16() = default;
    template <int B, bool S> int10ns16(const VBit<B, S>& a) : val(a) {}
    int10ns16(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> int10ns16(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    int10ns16(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const int10ns16& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, int10ns16& x) { is >> x.val; return is; }
public:
};
inline const int10ns16::BitType& toBitType(const int10ns16& v) { return v.val; }

class int10ps16
{
public:
    typedef VBit<10, true> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    int10ps16() = default;
    template <int B, bool S> int10ps16(const VBit<B, S>& a) : val(a) {}
    int10ps16(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> int10ps16(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    int10ps16(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const int10ps16& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, int10ps16& x) { is >> x.val; return is; }
public:
};
inline const int10ps16::BitType& toBitType(const int10ps16& v) { return v.val; }

class int12
{
public:
    typedef VBit<12, true> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    int12() = default;
    template <int B, bool S> int12(const VBit<B, S>& a) : val(a) {}
    int12(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> int12(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    int12(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const int12& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, int12& x) { is >> x.val; return is; }
public:
};
inline const int12::BitType& toBitType(const int12& v) { return v.val; }

class int12s2
{
public:
    typedef VBit<12, true> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    int12s2() = default;
    template <int B, bool S> int12s2(const VBit<B, S>& a) : val(a) {}
    int12s2(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> int12s2(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    int12s2(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const int12s2& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, int12s2& x) { is >> x.val; return is; }
public:
};
inline const int12s2::BitType& toBitType(const int12s2& v) { return v.val; }

class int13s2
{
public:
    typedef VBit<13, true> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    int13s2() = default;
    template <int B, bool S> int13s2(const VBit<B, S>& a) : val(a) {}
    int13s2(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> int13s2(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    int13s2(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const int13s2& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, int13s2& x) { is >> x.val; return is; }
public:
};
inline const int13s2::BitType& toBitType(const int13s2& v) { return v.val; }

class int16
{
public:
    typedef VBit<16, true> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    int16() = default;
    template <int B, bool S> int16(const VBit<B, S>& a) : val(a) {}
    int16(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> int16(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    int16(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const int16& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, int16& x) { is >> x.val; return is; }
public:
};
inline const int16::BitType& toBitType(const int16& v) { return v.val; }

class int20
{
public:
    typedef VBit<20, true> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    int20() = default;
    template <int B, bool S> int20(const VBit<B, S>& a) : val(a) {}
    int20(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> int20(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    int20(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const int20& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, int20& x) { is >> x.val; return is; }
public:
};
inline const int20::BitType& toBitType(const int20& v) { return v.val; }

class int20p
{
public:
    typedef VBit<20, true> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    int20p() = default;
    template <int B, bool S> int20p(const VBit<B, S>& a) : val(a) {}
    int20p(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> int20p(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    int20p(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const int20p& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, int20p& x) { is >> x.val; return is; }
public:
};
inline const int20p::BitType& toBitType(const int20p& v) { return v.val; }

class int21s2
{
public:
    typedef VBit<21, true> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    int21s2() = default;
    template <int B, bool S> int21s2(const VBit<B, S>& a) : val(a) {}
    int21s2(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> int21s2(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    int21s2(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const int21s2& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, int21s2& x) { is >> x.val; return is; }
public:
    int21s2(int13s2);
    int21s2(int12s2);
    int21s2(int9s2);
};
inline const int21s2::BitType& toBitType(const int21s2& v) { return v.val; }

class int26
{
public:
    typedef VBit<26, true> BitType;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    int26() = default;
    template <int B, bool S> int26(const VBit<B, S>& a) : val(a) {}
    int26(const VBitWrapper& a) : val(a) {}
    template <typename DataType, int E> int26(const VBitVector<DataType, E>& a) : val(a) {}
public:
    // backwards compatibility api
    int26(BitType::ValueType a) : val(a) {}
    BitType::ValueType& value() { return val.value(); }
    const BitType::ValueType& value() const { return val.value(); }
    void value(const BitType::ValueType& v) { val.value(v); }
    BitType::UBaseType to_unsigned() const { return val.to_unsigned(); }
    BitType::SBaseType to_signed() const { return val.to_signed(); }
    friend std::ostream& operator<<(std::ostream& os, const int26& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, int26& x) { is >> x.val; return is; }
public:
};
inline const int26::BitType& toBitType(const int26& v) { return v.val; }

class v4uint1
{
public:
    typedef VBitVector<uint1, 4> BitType;
    typedef BitType::handle handle;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    v4uint1() = default;
    template <typename DataType, int E> v4uint1(const VBitVector<DataType, E>& a) : val(a) {}
    v4uint1(const VBitWrapper& a) : val(a) {}
    template <int B, bool S> v4uint1(const VBit<B, S>& a) : val(a) {}
    // backwards compatibility api
    uint1& elem(int i) { return val.elem(i); }
    const uint1& elem(int i) const { return val.elem(i); }
    void elem(int i, const uint1& a) { val.elem(i, a); }
    handle value() { return val.value(); }
    handle value() const { return val.value(); }
    v4uint1(unsigned long long a) : val(a) {}
    void value(unsigned long long a) { val = a; }
    unsigned long long to_unsigned() const { unsigned long long tmp[(bits + 63) / 64]; val.to_unsigned(tmp); return tmp[0]; }
    long long to_signed() const { long long tmp[(bits + 63) / 64]; val.to_signed(tmp); return tmp[0]; }
    friend std::ostream& operator<<(std::ostream& os, const v4uint1& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, v4uint1& x) { is >> x.val; return is; }
    uint1& getElement(int i) { return elem(i); }
    const uint1& getElement(int i) const { return elem(i); }
    void putElement(const uint1& a, int i) { elem(i, a); }
public:
};
inline const v4uint1::BitType& toBitType(const v4uint1& v) { return v.val; }

class v4uint8
{
public:
    typedef VBitVector<uint8, 4> BitType;
    typedef BitType::handle handle;
    static const int bits = BitType::bits;
    static const bool isSigned = BitType::isSigned;
    BitType val;
public:
    v4uint8() = default;
    template <typename DataType, int E> v4uint8(const VBitVector<DataType, E>& a) : val(a) {}
    v4uint8(const VBitWrapper& a) : val(a) {}
    template <int B, bool S> v4uint8(const VBit<B, S>& a) : val(a) {}
    // backwards compatibility api
    uint8& elem(int i) { return val.elem(i); }
    const uint8& elem(int i) const { return val.elem(i); }
    void elem(int i, const uint8& a) { val.elem(i, a); }
    handle value() { return val.value(); }
    handle value() const { return val.value(); }
    v4uint8(unsigned long long a) : val(a) {}
    void value(unsigned long long a) { val = a; }
    unsigned long long to_unsigned() const { unsigned long long tmp[(bits + 63) / 64]; val.to_unsigned(tmp); return tmp[0]; }
    long long to_signed() const { long long tmp[(bits + 63) / 64]; val.to_signed(tmp); return tmp[0]; }
    friend std::ostream& operator<<(std::ostream& os, const v4uint8& x) { os << x.val; return os; }
    friend std::istream& operator>>(std::istream& is, v4uint8& x) { is >> x.val; return is; }
    uint8& getElement(int i) { return elem(i); }
    const uint8& getElement(int i) const { return elem(i); }
    void putElement(const uint8& a, int i) { elem(i, a); }
public:
};
inline const v4uint8::BitType& toBitType(const v4uint8& v) { return v.val; }


//  Conversions

inline w32::w32(uint5 a)                 { val = toVBit(a); }
inline w32::w32(int6 a)                  { val = toVBit(a); }
inline w32::w32(int6p a)                 { val = toVBit(a); }
inline w32::w32(int6n a)                 { val = toVBit(a); }
inline w32::w32(uint6_1_31 a)            { val = toVBit(a); }
inline w32::w32(uint7s4 a)               { val = toVBit(a); }
inline w32::w32(uint8s4 a)               { val = toVBit(a); }
inline w32::w32(int10ns16 a)             { val = toVBit(a); }
inline w32::w32(int10ps16 a)             { val = toVBit(a); }
inline w32::w32(int12 a)                 { val = toVBit(a); }
inline w32::w32(uint12 a)                { val = toVBit(a); }
inline w32::w32(uint10nz4 a)             { val = toVBit(a); }

inline addr::addr(w32 a)                 { val = toVBit(a); }

inline uint5::uint5(uint5nz a)           { val = toVBit(a); }

inline int21s2::int21s2(int13s2 a)       { val = toVBit(a); }
inline int21s2::int21s2(int12s2 a)       { val = toVBit(a); }
inline int21s2::int21s2(int9s2 a)        { val = toVBit(a); }

inline w32 lui(int20p a)                { return w32::BitType((w32::BitType(toVBit(a)) << 12)); }

//  Operations

checkers_import_export /*primitive*/ w32 add(w32, w32);
checkers_import_export /*primitive*/ w32 sub(w32, w32);
checkers_import_export /*primitive*/ w32 band(w32, w32);
checkers_import_export /*primitive*/ w32 bor(w32, w32);
checkers_import_export /*primitive*/ w32 bxor(w32, w32);

checkers_import_export /*primitive*/ w32 mul(w32, w32);
checkers_import_export /*primitive*/ w32 mulh(w32, w32);
checkers_import_export /*primitive*/ w32 mulhsu(w32, w32);
checkers_import_export /*primitive*/ w32 mulhu(w32, w32);
checkers_import_export /*primitive*/ w32 mac(w32, w32, w32);
checkers_import_export /*primitive*/ w32 dotp(w32, w32);
checkers_import_export /*primitive*/ w32 sdotp(w32, w32, w32);
checkers_import_export /*primitive*/ w32 sll(w32, w32);
checkers_import_export /*primitive*/ w32 srl(w32, w32);
checkers_import_export /*primitive*/ w32 sra(w32, w32);

checkers_import_export /*primitive*/ w32 slt(w32, w32);
checkers_import_export /*primitive*/ w32 sltu(w32, w32);

checkers_import_export /*primitive*/ bool eq(w32, w32);
checkers_import_export /*primitive*/ bool ne(w32, w32);
checkers_import_export /*primitive*/ bool lt(w32, w32);
checkers_import_export /*primitive*/ bool ge(w32, w32);
checkers_import_export /*primitive*/ bool ltu(w32, w32);
checkers_import_export /*primitive*/ bool geu(w32, w32);

checkers_import_export /*primitive*/ w32 extend_sign(w08);
checkers_import_export /*primitive*/ w32 extend_zero(w08);
checkers_import_export /*primitive*/ w32 extend_sign(w16);
checkers_import_export /*primitive*/ w32 extend_zero(w16);
checkers_import_export /*primitive*/ w08 extract_w08(w32);
checkers_import_export /*primitive*/ w16 extract_w16(w32);

checkers_import_export /*primitive*/ w32 divs(w32, w32);
checkers_import_export /*primitive*/ w32 rems(w32, w32);

checkers_import_export /*primitive*/ w32 divu(w32, w32);
checkers_import_export /*primitive*/ w32 remu(w32, w32);

//cntrl:  checkers_import_export /*primitive*/ void br(bool, int21s2);

//cntrl:  checkers_import_export /*primitive*/ w32 jal(int21s2);
//cntrl:  checkers_import_export /*primitive*/ w32 jalr(w32);

//cntrl:  checkers_import_export /*primitive*/ void j(int21s2);
//cntrl:  checkers_import_export /*primitive*/ void jr(w32);

checkers_import_export /*primitive*/ void nop();

checkers_import_export /*primitive*/ w32 zero_extend_08(w32);
checkers_import_export /*primitive*/ w32 zero_extend_16(w32);


} //namespace tzscale_primitive
#ifdef CHESS_NATIVE_NAMESPACE
} //namespace CHESS_NATIVE_NAMESPACE
#endif

#endif /*_tzscale_iss_types_h*/
