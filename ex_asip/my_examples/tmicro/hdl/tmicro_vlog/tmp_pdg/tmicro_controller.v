
// File generated by pdg version O-2018.09#f5599cac26#190121, Tue May 28 10:45:21 2024
// Copyright 2014-2018 Synopsys, Inc. All rights reserved.
// pdg -B -I../lib -I../lib/isg -D__go__ -pcu -Verilog -cgo_options.cfg -D__tct_patch__=300 +wtmicro_vlog/tmp_pdg tmicro


// Storages local to the pcu
reg               reg_booting;
reg               pdg_update_reg_booting;
reg               pdg_we_reg_booting;
reg               reg_debug_mode;
reg               pdg_update_reg_debug_mode;
reg               pdg_we_reg_debug_mode;
reg        [15:0] reg_f_instr;
reg        [15:0] pdg_update_reg_f_instr;
reg               pdg_we_reg_f_instr;
reg               reg_fetch;
reg               pdg_update_reg_fetch;
reg               pdg_we_reg_fetch;
reg               reg_halted;
reg               pdg_update_reg_halted;
reg               pdg_we_reg_halted;
reg               debug_mode;
reg               trn_interrupted;

// user_issue
always @ (*)
begin : p_user_issue
  reg               trn_interrupted_var;
  reg               debug_mode_var;
  reg        [15:0] f_instr;
  reg               jcr_taken;
  reg               jc_taken;
  reg               issue_ins;
  reg               interruptible;
  reg         [3:0] i_vector;
  reg         [7:0] i_ack;
  reg               check_interrupts_result;
  reg         [7:0] i_mask;
  reg         [7:0] mreq;
  reg               stop_issue;
  reg        [15:0] pdg_encoding_swi_result;
  reg        [15:0] swi_instr;

  trn_ID_valid_out = 0;
  trn_IR_ID_out = 0;
  kill_ID_out = 1'b0;
  mcw_kill_out = 1'b0;
  debug_mode = 0;
  debug_out_out = 0;
  halted_out_out = 0;
  iack_pcu_out_out = 0;
  trace_data_valid_out = 0;
  trn_interrupted = 0;

  check_interrupts_result = 0;
  i_mask = 0;
  mreq = 0;
  pdg_encoding_swi_result = 0;
  swi_instr = 0;

  pdg_we_reg_debug_mode = 1'b0;
  pdg_update_reg_debug_mode = 0;
  pdg_we_reg_f_instr = 1'b0;
  pdg_update_reg_f_instr = 0;

  f_instr = reg_f_instr;
  jcr_taken = jcr_in && tcc_in;
  jc_taken = jc_in && tcc_in;
  issue_ins = issue_sig_in && !jcr_taken && !jc_taken;
  if (reg_fetch)
  begin
    f_instr = pm_read_in;
  end
  interruptible = issue_ins && diid_in == 1'b0 && die1_in == 1'b0;
  debug_mode_var = ocd_req_in && interruptible;
  i_vector = 4'b0000;
  i_ack = 8'b00000000;
  trn_interrupted_var = 1'b0;
  if (interruptible && !ocd_dis_int_in && !debug_mode_var && ier_in == 1'b1)
  begin
    i_mask = imr_in;
    mreq = ireq_pcu_inp_in & i_mask;
    if (ireq_pcu_inp_in[0])
    begin
      i_vector = 4'b0000;
      i_ack = 8'b00000001;
      check_interrupts_result = 1'b1;
    end
    else
    begin
      if (mreq[1])
      begin
        i_vector = 4'b0010;
        i_ack = 8'b00000010;
        check_interrupts_result = 1'b1;
      end
      else
      begin
        if (mreq[2])
        begin
          i_vector = 4'b0100;
          i_ack = 8'b00000100;
          check_interrupts_result = 1'b1;
        end
        else
        begin
          if (mreq[3])
          begin
            i_vector = 4'b0110;
            i_ack = 8'b00001000;
            check_interrupts_result = 1'b1;
          end
          else
          begin
            if (mreq[4])
            begin
              i_vector = 4'b1000;
              i_ack = 8'b00010000;
              check_interrupts_result = 1'b1;
            end
            else
            begin
              if (mreq[5])
              begin
                i_vector = 4'b1010;
                i_ack = 8'b00100000;
                check_interrupts_result = 1'b1;
              end
              else
              begin
                if (mreq[6])
                begin
                  i_vector = 4'b1100;
                  i_ack = 8'b01000000;
                  check_interrupts_result = 1'b1;
                end
                else
                begin
                  if (mreq[7])
                  begin
                    i_vector = 4'b1110;
                    i_ack = 8'b10000000;
                    check_interrupts_result = 1'b1;
                  end
                  else
                  begin
                    check_interrupts_result = 1'b0;
                  end
                end
              end
            end
          end
        end
      end
    end
    trn_interrupted_var = check_interrupts_result;
  end
  stop_issue = reg_booting || reg_halted || debug_mode_var || reg_debug_mode;
  if (jcr_taken)
  begin
    mcw_kill_out = 1;
    kill_ID_out = 1;
  end
  trace_data_valid_out = 1'b0;
  if (trn_interrupted_var)
  begin
    pdg_encoding_swi_result = {12'b001011100111 , i_vector};
    swi_instr = pdg_encoding_swi_result;
    trace_data_valid_out = 1'b1;
    trn_ID_valid_out = 1;
    trn_IR_ID_out = swi_instr;
  end
  else
  begin
    if (ocd_exe_in)
    begin
      trn_ID_valid_out = 1;
      trn_IR_ID_out = ocd_instr_r_in;
    end
    else
    begin
      if (mw_stall_in)
      begin
        trn_ID_valid_out = 0;
        trn_IR_ID_out = f_instr;
      end
      else
      begin
        if (issue_ins && !stop_issue)
        begin
          trace_data_valid_out = 1'b1;
          trn_ID_valid_out = 1;
          trn_IR_ID_out = f_instr;
        end
      end
    end
  end
  halted_out_out = reg_halted;
  debug_out_out = reg_debug_mode;
  iack_pcu_out_out = i_ack;
  pdg_we_reg_debug_mode = 1'b1;
  pdg_update_reg_debug_mode = debug_mode_var;
  pdg_we_reg_f_instr = 1'b1;
  pdg_update_reg_f_instr = f_instr;
  debug_mode = debug_mode_var;
  trn_interrupted = trn_interrupted_var;
end //p_user_issue


// user_next_pc
always @ (*)
begin : p_user_next_pc
  reg               lp_jump;
  reg               lp_done;
  reg               lp_update;
  reg        [15:0] tlcr;
  reg        [15:0] tlsr;
  reg        [15:0] tler;
  reg               new_fetch;
  reg        [15:0] nextpc;
  reg signed  [7:0] t_offs;
  reg               new_fetch_0;
  reg               advance_pc;

  LC_lcr_cntrl_nxtpc_pdg_r_a_out = 0;
  LC_lcr_cntrl_nxtpc_pdg_r_en_out = 0;
  LC_lcw_cntrl_nxtpc_pdg_en_out = 0;
  LC_lcw_cntrl_nxtpc_pdg_w_a_out = 0;
  LE_ler_cntrl_nxtpc_pdg_r_a_out = 0;
  LE_ler_cntrl_nxtpc_pdg_r_en_out = 0;
  LF_lfw_cntrl_nxtpc_pdg_en_out = 0;
  LS_lsr_cntrl_nxtpc_pdg_r_a_out = 0;
  LS_lsr_cntrl_nxtpc_pdg_r_en_out = 0;
  PC_pcw_cntrl_nxtpc_pdg_en_out = 0;
  lcw_out = 0;
  lfw_out = 0;
  lnk_if_out = 0;
  lnk_pf_out = 0;
  pcw_out = 0;
  pm_addr_out = 0;
  pm_ld_pdg_en_out = 0;
  trace_data_out = 0;

  t_offs = 0;
  new_fetch_0 = 0;
  advance_pc = 0;

  pdg_we_reg_booting = 1'b0;
  pdg_update_reg_booting = 0;
  pdg_we_reg_fetch = 1'b0;
  pdg_update_reg_fetch = 0;
  pdg_we_reg_halted = 1'b0;
  pdg_update_reg_halted = 0;

  lnk_if_out = pcr_in;
  lnk_pf_out = pcr_in + 16'b0000000000000001;
  lp_jump = 1'b0;
  lp_done = 1'b0;
  lp_update = 1'b0;
  tlcr = 16'b0000000000000000;
  tlsr = 16'b0000000000000000;
  tler = 16'b0000000000000000;
  if (lfra_in < 2'b11)
  begin
    LC_lcr_cntrl_nxtpc_pdg_r_en_out = 1'b1;
    LC_lcr_cntrl_nxtpc_pdg_r_a_out = lfra_in;
    tlcr = lcr_in;
    LS_lsr_cntrl_nxtpc_pdg_r_en_out = 1'b1;
    LS_lsr_cntrl_nxtpc_pdg_r_a_out = lfra_in;
    tlsr = lsr_in;
    LE_ler_cntrl_nxtpc_pdg_r_en_out = 1'b1;
    LE_ler_cntrl_nxtpc_pdg_r_a_out = lfra_in;
    tler = ler_in;
    if (pcr_in == tler)
    begin
      if (tlcr == 16'b0000000000000001)
      begin
        lp_done = 1'b1;
      end
      else
      begin
        lp_jump = 1'b1;
      end
    end
  end
  new_fetch = !(trn_interrupted || reg_halted || debug_mode);
  nextpc = pcr_in;
  if (en_jump_offs_sig)
  begin
    t_offs = offs_in;
    nextpc = pcr_in + {{8{t_offs[7]}}, t_offs};
  end
  else
  begin
    if (en_jump_trgt_sig)
    begin
      nextpc = trgt_in;
    end
    else
    begin
      new_fetch_0 = new_fetch;
      new_fetch = new_fetch_0 & (issue_sig_in || mw_stall_in);
      advance_pc = new_fetch && !(reg_booting || reg_debug_mode);
      if (advance_pc)
      begin
        lp_update = 1'b1;
        if (lp_jump)
        begin
          nextpc = tlsr;
        end
        else
        begin
          nextpc = pcr_in + 16'b0000000000000001;
        end
      end
    end
  end
  if (lp_update)
  begin
    if (lp_jump)
    begin
      LC_lcw_cntrl_nxtpc_pdg_w_a_out = lfra_in;
      LC_lcw_cntrl_nxtpc_pdg_en_out = 1'b1;
      lcw_out = tlcr - 16'b0000000000000001;
    end
    if (lp_done)
    begin
      LF_lfw_cntrl_nxtpc_pdg_en_out = 1'b1;
      lfw_out = lfra_in - 2'b01;
    end
  end
  if (new_fetch)
  begin
    pm_addr_out = nextpc;
    pm_ld_pdg_en_out = 1'b1;
  end
  PC_pcw_cntrl_nxtpc_pdg_en_out = 1'b1;
  pcw_out = nextpc;
  pdg_we_reg_fetch = 1'b1;
  pdg_update_reg_fetch = new_fetch;
  pdg_we_reg_booting = 1'b1;
  pdg_update_reg_booting = 1'b0;
  if (en_vd_halt_ID)
  begin
    pdg_we_reg_halted = 1'b1;
    pdg_update_reg_halted = 1'b1;
  end
  else
  begin
    if (trn_interrupted)
    begin
      pdg_we_reg_halted = 1'b1;
      pdg_update_reg_halted = 1'b0;
    end
  end
  trace_data_out = pcr_in;
end //p_user_next_pc


always @ (posedge clock or posedge reset)
begin : p_update_status
  if (reset)
  begin
    reg_booting <= 1'b1;
    reg_debug_mode <= 1'b0;
    reg_f_instr <= 16'b0000000000000000;
    reg_fetch <= 1'b0;
    reg_halted <= 1'b0;
  end
  else
  begin
    if (pdg_we_reg_booting)
      reg_booting <= pdg_update_reg_booting;
    if (pdg_we_reg_debug_mode)
      reg_debug_mode <= pdg_update_reg_debug_mode;
    if (pdg_we_reg_f_instr)
      reg_f_instr <= pdg_update_reg_f_instr;
    if (pdg_we_reg_fetch)
      reg_fetch <= pdg_update_reg_fetch;
    if (pdg_we_reg_halted)
      reg_halted <= pdg_update_reg_halted;
  end
end // p_update_status
