
// File generated by animal version O-2018.09#f5599cac26#190121, Tue May 28 12:03:14 2024
// Copyright 2014-2018 Synopsys, Inc. All rights reserved.
// animal -A -B -Iisg +wisg -Iruntime/include -D__tct_patch__=300 -h -d 5 -v -p +r -D__darts__ -D__programmers_view__ tzscale


// This file reports all potential pipeline hazards in tzscale,
// and lists where sw_stall rules are added to avoid them.
// These added sw_stall rules complement user-defined hw_stall and bypass rules,
// and never overlap with them.

// Also simple sw_stall rules are proposed in nML syntax, but these may OVERLAP
// with user-defined hw_stall or bypass rules:
// - don't just copy, but make them specific to eliminate overlap,
// - or rely on the internally added sw_stall rules.

// The (new) default pipeline hazard covering algorithm may add sw_stall rules
// that overlap with other, user-defined sw_stall rules, when the latter
// only partially cover a dependency.This overlap can be avoided by setting
// nML property 'property allow_overlapping_sw_stalls: false;'

// Use option +d4, +d8, +d12, +d16 for increasingly more details on
// the pipeline hazards and how they are covered.

// The old hazard covering algorithm is still used for odd +d values:
// +d1,+d5,+d7,+d9,+d11,... 
// +d3 (non-recommended) checks dependencies on the nML source line level,
// and may add much more sw_stall rules that each cover less instructions.
// For even +d values not a multiple of 4 (+d2,+d6,+d10...) the new hazards
// covering is executed after the old algorithm.

// with the animal -v (verbose) option ALL SOURCE REFERENCES are printed;
// without it ONLY ONE source reference is printed for each operation.

// with option -n source line references with nML derivation paths are printed
// (this may be slow when more references are printed for higher +d levels)

// with option -s (combined with +d level higher than 1) instructions are
// printed as bit-string patterns (may be slow)

// This file was created with +d5


//                         -------------------------

// WAW data hazard for cycle offset [1,1] on R {
//   R_wr_w1___R_w1_wad_WB
//      [alu.n:58] rd `WB` = PD `WB`;
//      [alu.n:74] rd `WB` = PD `WB`;
//      [alu.n:124] rd `WB` = PD `WB`;
//      [alu.n:139] rd `WB` = PD `WB`;
//      [alu.n:160] rd `WB` = PD `WB`;
//      [alu.n:175] rd `WB` = PD `WB`;
//      [alu.n:192] rd `WB` = PD `WB`;
//      [alu.n:207] rd `WB` = PD `WB`;
//      [alu.n:220] rd `WB` = PD `WB`;
//      [ldst.n:37] rd `WB` = lxC `WB` = extend_sign (lxB `WB` = dmb_rd `WB`)  @lx;
//      [ldst.n:39] rd `WB` = lxC `WB` = extend_zero (lxB `WB` = dmb_rd `WB`)  @lx;
//      [ldst.n:41] rd `WB` = lxC `WB` = extend_sign (lxH `WB` = dmh_rd `WB`)  @lx;
//      [ldst.n:43] rd `WB` = lxC `WB` = extend_zero (lxH `WB` = dmh_rd `WB`)  @lx;
//      [ldst.n:45] rd `WB` = lxC `WB` = dmw_rd `WB`;
//      [alu.n:92] rd `WB` = PD `WB`;
//      [alu.n:109] rd `WB` = PD `WB`;
//      [bits16.n:136] rd `WB` = PD `WB`;
//      [bits16.n:176] R[2] `WB` = w1 `WB` = PD `WB`;
//      [bits16.n:305] rd `WB` = PD `WB`;
//      [bits16.n:316] rd `WB` = lxC `WB` = dmw_rd `WB`;
//      [bits16.n:329] rd `WB` = PD `WB`;
//      [bits16.n:342] rd `WB` = PD `WB`;
//      [regfile.n:70] R[r] = w1 = (alu.n:58) PD `WB`
//      [regfile.n:70] R[r] = w1 = (alu.n:74) PD `WB`
//      [regfile.n:70] R[r] = w1 = (alu.n:124) PD `WB`
//      [regfile.n:70] R[r] = w1 = (alu.n:139) PD `WB`
//      [regfile.n:70] R[r] = w1 = (alu.n:160) PD `WB`
//      [regfile.n:70] R[r] = w1 = (alu.n:175) PD `WB`
//      [regfile.n:70] R[r] = w1 = (alu.n:192) PD `WB`
//      [regfile.n:70] R[r] = w1 = (alu.n:207) PD `WB`
//      [regfile.n:70] R[r] = w1 = (alu.n:220) PD `WB`
//      [regfile.n:70] R[r] = w1 = (ldst.n:37) lxC `WB`
//      [regfile.n:70] R[r] = w1 = (ldst.n:39) lxC `WB`
//      [regfile.n:70] R[r] = w1 = (ldst.n:41) lxC `WB`
//      [regfile.n:70] R[r] = w1 = (ldst.n:43) lxC `WB`
//      [regfile.n:70] R[r] = w1 = (ldst.n:45) lxC `WB`
//      [regfile.n:70] R[r] = w1 = (alu.n:92) PD `WB`
//      [regfile.n:94] R[r] = w1 = (alu.n:109) PD `WB`
//      [regfile.n:70] R[r] = w1 = (bits16.n:136) PD `WB`
//      [regfile.n:70] R[r] = w1 = (bits16.n:305) PD `WB`
//      [regfile.n:70] R[r] = w1 = (bits16.n:316) lxC `WB`
//      [regfile.n:70] R[r] = w1 = (bits16.n:329) PD `WB`
//      [regfile.n:70] R[r] = w1 = (bits16.n:342) PD `WB`
//   R8_15_wr_w1___R8_15_w1_wad_WB
//      [bits16.n:93] rd `WB` = PD `WB`;
//      [bits16.n:104] rd `WB` = lxC `WB` = dmw_rd `WB`;
//      [bits16.n:189] rd `WB` = PD `WB`;
//      [bits16.n:202] rd `WB` = PD `WB`;
//      [bits16.n:216] rd `WB` = PD `WB`;
//      [bits16.n:229] rd `WB` = PD `WB`;
//      [bits16.n:242] rd `WB` = PD `WB`;
//      [bits16.n:255] rd `WB` = PD `WB`;
//      [bits16.n:268] rd `WB` = PD `WB`;
//      [regfile.n:105] R8_15[r] = w1 = (bits16.n:93) PD `WB`
//      [regfile.n:105] R8_15[r] = w1 = (bits16.n:104) lxC `WB`
//      [regfile.n:105] R8_15[r] = w1 = (bits16.n:189) PD `WB`
//      [regfile.n:105] R8_15[r] = w1 = (bits16.n:202) PD `WB`
//      [regfile.n:105] R8_15[r] = w1 = (bits16.n:216) PD `WB`
//      [regfile.n:105] R8_15[r] = w1 = (bits16.n:229) PD `WB`
//      [regfile.n:105] R8_15[r] = w1 = (bits16.n:242) PD `WB`
//      [regfile.n:105] R8_15[r] = w1 = (bits16.n:255) PD `WB`
//      [regfile.n:105] R8_15[r] = w1 = (bits16.n:268) PD `WB`
// } -> { 
//   R_wr_wd___R_wd_wad_DE
// }

// NOTE: Second pattern contains a multi-cycle operation, for:
//   R_wr_wd___R_wd_wad_DE
//      [div.n:59] R[div_wad = rd] `DE` = wd `DE` = divC `DE` = divs (divA `DE` = rs1 `DE`, divB `DE` = rs2 `DE`)  @div;
//      [div.n:69] R[div_wad = rd] `DE` = wd `DE` = divC `DE` = rems (divA `DE` = rs1 `DE`, divB `DE` = rs2 `DE`)  @div;
//      [div.n:38] R[div_wad = rd] `DE` = wd `DE` = divC `DE` = divu (divA `DE` = rs1 `DE`, divB `DE` = rs2 `DE`)  @div;
//      [div.n:48] R[div_wad = rd] `DE` = wd `DE` = divC `DE` = remu (divA `DE` = rs1 `DE`, divB `DE` = rs2 `DE`)  @div;
// NOTE: Hazards for multi-cycle units cannot be handled by sw_stalls, but require a hw_stall activated by a transitory.



Checking for overlapping bypasses:
==================================

	None

Checking for hw_stall overlapping with bypass:
==============================================

	None
