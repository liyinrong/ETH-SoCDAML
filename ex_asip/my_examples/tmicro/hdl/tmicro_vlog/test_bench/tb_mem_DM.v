
// File generated by Go version O-2018.09#f5599cac26#190121, Tue May 28 10:45:22 2024
// Copyright 2014-2018 Synopsys, Inc. All rights reserved.
// go -B -I../lib -F -D__tct_patch__=300 -Verilog -otmicro_vlog -cgo_options.cfg -Itmicro_vlog/tmp_pdg -updg -updg_controller tmicro



`timescale 1ns/1ps

// module tb_mem_DM :  tb_mem_DM
module tb_mem_DM
  #(parameter DM_addr_size = 16,
    parameter DM_data_size = 16,
    parameter DM_file = "data.DM",
    parameter DM_id = 1,
    parameter DM_size = 65536,
    parameter reg_log = 1'b1
  )
  ( input                reset,
    input                clock,
    input         [15:0] dm_addr_in, // addr
    input                dm_ld_in, // std_logic
    input                dm_st_in, // std_logic
    input  signed [15:0] dm_write_in, // word
    output signed [15:0] dm_read_out // word
  );


  reg signed [15:0] DM[0:DM_size - 1];

  event value_changed;

  wire   [15:0] dm_addr;
  wire   dm_ld;
  reg    signed [15:0] dm_read;
  wire   dm_st;
  wire   signed [15:0] dm_write;

  reg signed [15:0] dm_read_DLY1;
  reg [15:0] dm_addr_DLY1;
  reg dm_st_nval;

  function [15:0] addr_DM (input [15:0] address);
    begin
      addr_DM = address;
      if (address < 0 || address >= DM_size)
      begin
        addr_DM = 0;
      end
    end
  endfunction

  // input/output port assignment
  assign dm_addr = dm_addr_in;
  assign dm_ld = dm_ld_in;
  assign dm_st = dm_st_in;
  assign dm_write = dm_write_in;
  assign dm_read_out = dm_read;

  always @ (posedge clock)
  begin
    dm_read <= dm_read_DLY1;
    dm_addr_DLY1 <= dm_addr;
  end

  always @ (value_changed or
            dm_ld or
            dm_addr)
  begin : mem_read_DM

    integer i;
    dm_read_DLY1 = 0;

    if (dm_ld) // dm_read_ld_DM_dm_addr_ID
    begin
      dm_read_DLY1 = DM[addr_DM(dm_addr)];
    end
    // dm_read_ld_DM_dm_addr_ocd_ld_DM_ID_alw also uses control signal dm_ld
  end

  // Allow change of the memory_init file at runtime:
  reg [255*8:1] appname = DM_file;
  reg [255*8:1] tmp_appname;
  integer appname_file;
  integer appname_scan_file;

  initial begin
    // check for plusarg:
    if ($value$plusargs("appname=%s",tmp_appname)) begin
      appname = {tmp_appname, ".DM"};
    end
    else begin
      // no plusarg found, check for appname.cfg file.
      // Note: Some simulators may print a harmless warning when 
      //       the file is not found. This can be safely ignored.
      appname_file = $fopen("appname.cfg", "r");
      if (appname_file != 0) begin
        if (!$feof(appname_file)) begin
          appname_scan_file = $fscanf(appname_file, "%s", tmp_appname);
          appname = {tmp_appname, ".DM"};
          $fclose(appname_file);
        end
      end
    end
  end

  always @ (posedge reset or posedge clock)
  begin : mem_write_DM

    integer i;
    if (reset)
    begin
      for ( i = 0; i <= DM_size - 1; i = i + 1)
        DM[i] = 0;
      $readmemh(appname, DM);
      -> value_changed;
    end
    else
    begin
      dm_st_nval = 0;

      if (dm_st) // DM_st_dm_write_dm_addr_E1
      begin
        DM[addr_DM(dm_addr)] = dm_write;

        dm_st_nval = 1;
        -> value_changed;
      end
      // DM_st_dm_write_dm_addr___ocd_st_DME1_r_E1_alw also uses control signal dm_st
    end
  end

  always @ (negedge clock)

  begin : mem_log_DM


    if (reg_log)
    begin
      if (dm_st_nval)
      begin
        $fdisplay(test_bench.inst_tmicro.inst_reg_PC.log_file,
                  "DM[%0d] = %0d", addr_DM(dm_addr_DLY1), $signed(DM[addr_DM(dm_addr_DLY1)]));

      end

    end
  end

endmodule
