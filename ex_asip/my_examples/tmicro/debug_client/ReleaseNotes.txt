
                  Debug Client Generation by Checkers
                            Release Notes

                             March, 2018

Copyright (c) 2014-2018 Synopsys, Inc. This processor model and the associated
documentation are proprietary to Synopsys, Inc.  This model may only be
used in accordance with the terms and conditions of a written license
agreement with Synopsys, Inc.  All other use, reproduction, or distribution
of this model are strictly prohibited.

0. Release history
==================

  1.  5-dec-2008    First release  (Section 1)
  2. 30-sep-2009    Software breakpoints and watchpoints (Section 2)
  3. 25-mar-2010    Vector types (Section 3)
  4. 27-aug-2010    Refinements to software breakpoints (Section 4)
  5. 27-dec-2010    Refinements to interaction interrupts (Section 5)
  6.  4-jan-2012    Multiprocessor synchronous stepping (Section 6)
  7. 10-may-2013    Memory protections and multiple contexts (Section 7)
  8. 10-feb-2016    Memory address step parameter (Section 8)
  9. 12-mar-2018    Removed restrictions on address and data width (Section 9)


1. Debug client generation
==========================

Checkers generates a processor-specific debug client in terms of a
processor-independent abstract debug interface. This abstract interface,
represented by the 'Checkers_debugger' class, is declared in the central
Checkers include file, called 'checkers_debugger.h'.

For every different processor, an implementation of this abstract
Checkers_debugger class must be provided. An example implementation is
available for the tmicro processor, interfacing with the Processor Debug
Controller (PDC) unit generated by Go, via a JTAG link. It consists of
following three classes:

  1) pdc_commands. This class is an interface around the jtag_socket library,
     driving the parallel or Amontec USB cable. It provides the basic PDC
     commands: register/memory access, reset/step/resume/request commands, and
     breakpoint commands.

  2) Checkers_pdc_interface. This class derived from Checkers_debugger,
     implements the Checkers_debugger interface in terms of the basic PDC
     commands provided in pdc_commands. This class implements the more complex
     but generic functionality like the register and memory read caches,
     software breakpoints, and is considered to be processor-independent.

  3) <processor>_pdc_interface. In this (optional) class, derived from
     Checkers_pdc_interface, processor-specific specializations can be
     done. Typically, some few virtual functions are redefined here.

For a new processor, when using the PDC unit generated by Go, only small
changes are required to the pdc_commands class, typically related to register
and memory access (e.g. the way data is moved between memories/registers and
the PDC data register is processor dependent). Further processor-specific
specializations can be implemented in the <processor>_pdc_interface class,
while the generic code in Checkers_pdc_interface should be left unaffected.

When using a 3rd party debugger DLL to interact with the target processor,
instead of using our default hardware link, also a pdc_commands implementation
is available showing how to interface with such a debugger DLL.

To build a debug client, following actions are required:

  - In ChessDE, you set following options:

       Debug client->Model->Controller: Debug client class name/header file

    where you specify <processor>_pdc_interface and its header file.

  - The register access is implemented by issuing register move instructions.
    These moves are listed in the assembly file 'pdc_register_moves.s' and are
    translated by the makefile 'makefile.ins' into pdc_register_moves.c,
    initializing the opcode of the register move instructions.

    This makefile also copies the pdc_opcodes.h file generated by Go,
    containing the opcodes for the PDC unit.



2. Rework of debug client interfaces for generalized breakpoints
================================================================

 Outline

  a. Overview of new functionality
  b. List of changes to Checkers_debugger class
  c. List of changes to pdc_commands class


2.a. Overview of new functionality
----------------------------------

 * Software breakpoints

   Software breakpoints involve few changes at the hardware side. The processor
   instruction set must be extended with a (single-word) sw-break instruction,
   putting the core in debug mode when executed.

   The main work is done in software, in the generic Checkers_pdc_interface
   class. When setting a breakpoint, the corresponding PM instruction is
   replaced by the sw-break instruction. When this instruction is hit, and you
   resume or step, the sw-break instruction is temporarily replaced by the
   original instruction. As software breakpoints do not work on programs in ROM
   sections, both hardware and software breakpoints are useful.

   In our example implementation, we assume that the sw-break instruction
   decrements the PC, such that the PC points again to the sw-break instruction
   after executing it (this has been generalized later on, see section 4). The
   reasons for this built-in PC decrement:

     - It is safer, as a simple resume or step command will never be able to
       continue (wrong) execution with the next instruction.

     - When the PC decrement is not done by the break itself (and is to be done
       in software), it is confusing when you stop just after a break
       instruction. Then, you need a separate status bit in the PDC unit to
       know whether the sw-break instruction has been executed or not, and
       thus, whether the original instruction must still be executed or not.

   The functions in Checkers_debugger to set/remove software breakpoints are:

      int add_sw_break(unsigned pc);
      int remove_sw_break(unsigned pc);

   So, currently, a software break has no options. An implementation can choose
   to export the software break or not (this has been generalised, see section
   6).

 * Watchpoints and generalized hardware breakpoints

   Watchpoints are similar to hardware breakpoints, but instead of comparing
   the PDC address registers with the instruction fetch address, PDC address
   registers are compared with the data memory address bus when storing (or
   loading) data.

   Watchpoints have typically more parameters than breakpoints. For example:

     - When doing address comparisons, you may want to discard some LSB bits,
       such that you can detect an access to a block of data.

     - By default you watch write actions, but maybe you also want to watch
       read actions.

     - You may want to combine the check on the address with a check on the
       data being stored or loaded. Also for this data comparison an optional
       data mask can be desired.

   Also for hardware breakpoints you can think of more parameters than the
   current export parameter.

   To support all this, the Checkers_debugger interface to enable/disable
   hardware breakpoints and watchpoints has been reworked:

     - The Checkers_debugger class defines two structs with all relevant
       parameters: Breakpoint_settings and Watchpoint_settings.

     - The Checkers_debugger functions to enable/disable hardware breakpoints
       and watchpoints:

         int enable_hw_break(const Breakpoint_settings*);
         int enable_hw_break(const Watchpoint_settings*);
         int disable_hw_break(int nr);

   The enable functions return a unique number (the handle), identifying the
   breakpoint or watchpoint (a negative number means failure). This number is
   used to derive which break or watch point has been hit, and also to remove
   the break or watch point. Typically, the number will correspond to the
   number of the PDC address register.

   Note that an implementation does not have to consider all parameters present
   in the structs. The GUI can be configured to only show the supported
   parameters.

   The previous breakpoint increment/decrement behavior in the
   Checkers_debugger interface has been removed. So, the GUI should do the
   necessary bookkeeping to ensure that only one breakpoint is set on a
   specific PC address.

 * More detailed processor status

   The previous get_status() function only returned a single value to reflect
   the processor status. Now this status is reflected by a struct containing
   more information:

     struct Core_status {
        bool running;
        bool hw_break;                // stopped at HW breakpoint/watchpoint
        std::vector<int> hw_break_nr; // hit HW breakpoint/watchpoint numbers
        bool external_break;          // stopped at external break in
        bool sw_break;                // stopped at SW breakpoint
     };
     void get_status(Core_status*);

   Some remarks:

     - The members reflect the contents of the PDC processor status register.
       For example, 'hw_break_nr' lists which individual breakpoints or
       watchpoints have been hit. By preference, once hit, these bits should
       remain set in the PDC status register, until a resume or step command is
       done. Then the GUI can always report the exact break/watchpoint that has
       been hit.

     - In our implementation, the 'sw_break' condition is only checked in
       software, in the Checkers_pdc_interface class, while the other members
       related to hardware breakpoints and watchpoints are set in the
       pdc_commands class, based on the PDC status register.


2.b. List of changes to Checkers_debugger class
-----------------------------------------------

Note that the changes to the Checkers_debugger interface do not always affect
the user code in a debug client. Most changes are handled in the generic
Checkers_pdc_interface class. Only the user-defined <processor>_pdc_interface
class, where you can specialize some Checkers_pdc_interface functions, can be
affected.

 * Changes involving backward incompatibilities

   - Different interface for the get_status() processor status function:

        void get_status(Core_status*);   // with Core_status a struct

   - The reset(int attach) function has been replaced by two separate
     functions:

        void reset_pdc();
        void reset_core(bool sync = false);

     reset_pdc() resets the PDC, i.e., software/hardware breaks, without
     affecting the processor core (same as reset(attach = 1) before).
     reset_core() resets the processor core without affecting the PDC, it has
     an optional synchronous argument.

   - The start/stop functions have an optional sync argument:

        void request(bool sync =false);
        void step(bool sync =false);
        void resume(bool sync =false);

     So, the sync_ version of these functions have been removed.

   - Different functions to set/remove hardware breakpoints and watch points:

        int enable_hw_break(const Breakpoint_settings*);
        int enable_hw_break(const Watchpoint_settings*);
        int disable_hw_break(int nr);

     The enable_hw_break() functions return a unique id (>= 0) to be used for
     removing the breakpoint/watchpoint. A negative number means failure.

   - Different interface for expand_to_root_locations() function:

        bool expand_into_root_locations(const Checkers_storinfo*);

     So, bool result (to differentiate with the functions returning an error
     code of type int), and const qualification for Checkers_storinfo.


 * Extra features

   - New functions to add/remove software breakpoints:

        int add_sw_break(unsigned pc) = 0;
        int remove_sw_break(unsigned pc) = 0;

   - Extra enumerator for error return codes:

        enum { ok = 0, failed = 1; };

     Returning 'ok' or 'failed' makes the code more clear, compared to
     returning 0 or 1.

   - A reference to the Checkers_uicore is added to debugger class:

        Checkers_uicore* uicore() const;
        Checkers_uicore* uicore(Checkers_uicore*);

     This can be useful when wanting to use Checkers API functions.

   - New function check_device(), that can be redefined by the user to verify
     whether a connection is made with the correct hardware.

        int check_device() const;

     By default this function returns 'ok'.


2.c. Changes to pdc_commands class
----------------------------------

The changes to the interface of the pdc_commands class are listed below:

   - Different interface for the get_status() processor status function:

        void get_status(Core_status*);

   - Following functions have extra sync argument (removed sync_ versions):

        void step(bool sync);
        void resume(bool sync);
        void request(bool sync);
        void reset_core(bool sync);

   - Different functions to enable/disable hardware breakpoints/watchpoints:

        bool watch_supported(string) const;
        void enable_hw_break(int nr, const Breakpoint_settings*);
        void enable_hw_break(int nr, const Watchpoint_settings*);
        void disable_hw_break(int nr);

     watch_supported(name) returns whether watchpoints are supported for the
     memory argument.
     enable_hw_break() does the enabling and exporting together.
     disable_hw_break() is identical to previous breakpoint_disable(), but can
     also be used to disable watchpoints.

   - Extra members containing the required software breakpoint info:

        static const bool sw_break_enabled = false;
        static const long long core_sw_break_instr = 0;
        static string pmem_name;

   - supported_regs() returns a vector<string> instead of list<string>



3. Rework of debug client interfaces for vector types
=====================================================

 Outline

  a. Overview of new functionality
  b. List of changes to Checkers_debugger class
  c. List of changes to pdc_commands class


3.a. Overview of new functionality
----------------------------------

 * Support for vector types

   Vector types can consist of many elements (up to 1024 for high-end image
   processors). In that case, only a restricted number of elements can be
   displayed in the GUI. Consequently, the access functions in the top-level
   Checkers_debugger interface, allow access to specific vector elements:

     int get_register(string name, unsigned elem, long long& value);
     int put_register(string name, unsigned elem, long long  value);
     int get_memory_at(string name, unsigned addr, unsigned elem, long long& v);
     int put_memory_at(string name, unsigned addr, unsigned elem, long long  v);

   The pdc_commands member vector_size(nm) returns the vector size of the
   register or memory with name "nm". It is assumed that always a block of
   vector elements is accessed on the target, so the pdc_commands access
   functions are:

     int get_register(string name, range elems);
     int get_memory_at(string name, unsigned address, range elems);
     void received_next(string name, range, vector<long long>& values);
     int put_register(string name, range elems,
                      const vector<long long>& values);
     int put_memory_at(string name, unsigned address, range elems,
                       const vector<long long>& values);

   A new vector cache in Checkers_pdc_interface does the translation from the
   single element access in Checkers_debugger to the block based access in
   pdc_commands. By default, blocks or cache lines are retrieved that cover 8
   consecutive addresses and 8 consecutive vector elements (64 elements in
   total). The cache sizes can be customized in the new file pdc_caches.h.
   Writes to consecutive vector elements are collected in a write merge buffer,
   with a default length of 8.

 * Reworked access of record memories

   By default, the PDC unit accesses the smallest addressable elements of a
   memory. However, in case of variable length instructions, typically, program
   memory only supports access to record words. E.g.:

      mem PM[2*16]<pm_type,uint16> read() write();
      mem LPM[2**15]<lpm_type,uint15> alias PM read(prb) write(pwb);

   So, LPM is a two-word record alias of PM, and only LPM can be accessed,
   while the Checkers debug client will do read/write access on the root memory
   PM.

   By returning two in the pdc_commands member vector_size() for program memory
   PM, the Checkers_pdc_interface will translate the single-word PM access to
   two-element vector access on pdc_commands. In the pdc_commands class, you
   then still have the option to retrieve the information as one long bit
   string (by packing/unpacking the vector elements).

   Note that the address increment of such an artificial vector memory in
   Checkers_pdc_interface is always one. For example, when vector_size() == 2,
   the vector address 'n' corresponds to the elements 2n and 2n+1 in the scalar
   memory.

 * Access of storages wider than 64-bit

   The Checkers_debugger interface only supports storage access up to 64-bit.
   Longer types are typical records or vector types, of which the elements are
   accessed instead. So, to work around the 64-bit restriction in the
   Checkers_debugger interface, you can declare the primitive storage type as
   vector type. Or for registers, you can declare a record structure in nML.

   Note that our jtag_socket library supports register scans of more than
   64-bit. So, in the pdc_commands class, you can still pack the vector type in
   a single bit string.

 * The class "pdc_mem_instr" defined in pdc_commands.h is no longer used in the
   interface between Checkers_pdc_interface and pdc_commands. So,
   implementations not using our jtag_socket library must no longer provide
   dummy pdc_mem_instr values.

 * Better control on loading of register cache.

   Previously, all supported registers were loaded in a single send-receive
   sequence. Now, the pdc_commands member supported_regs() has been replaced by
   common_regs(), which can be empty. The "common" registers are still loaded
   together, while additional registers are only loaded on request (but are
   also stored in the read cache).

   When the pdc_commands member common_regs() returns an empty list, all
   registers will be loaded via following pdc_commands member:

     int get_register(string name, long long& value);

   so avoiding the send-and-receive mechanism for loading registers.

 * An example implementation has been provided of pdc_commands in case the
   connection with the target happens via a 3rd party DLL instead of our default
   JTAG/PDC interface (files 3rd_party_dll/pdc_commands.[ch]).


3.b. List of changes to Checkers_debugger interface
--------------------------------------------------

 * Extra functions to support element access of vector registers and memories:

     int get_register(string name, unsigned elem, long long& value);
     int put_register(string name, unsigned elem, long long  value);
     int get_memory_at(string name, unsigned addr, unsigned elem, long long& v);
     int put_memory_at(string name, unsigned addr, unsigned elem, long long  v);


3.c. Changes to pdc_commands class
----------------------------------

 * Member supported_regs() replaced by common_regs():

     vector<string> common_regs();

   When this function returns an empty vector, all registers will be loaded
   via the 'get_register(string, long long&)' member.

 * The memory access functions have now the memory name as argument (was
   pdc_mem_instr before).

    int put_memory_at(string name, unsigned address, long long value);
    int get_memory_at(string name, unsigned address);

   The return value has changed from void to int, to indicate whether the
   memory access succeeded.

 * New members for vector storage access:

     unsigned vector_size(string name);
     vector<string> common_vec_regs(unsigned vec_size);
     int get_register(string name, range elems);
     int get_memory_at(string name, unsigned address, range elems);
     void received_next(string name, range, vector<long long>& values);
     int put_register(string name, range elems,
                      const vector<long long>& values);
     int put_memory_at(string name, unsigned address, range elems,
                       const vector<long long>& values);

   In absence of vector types (when vector_size() returns zero), dummy
   implementations can be provided.

 * The support for "sub-word" access in the pdc_mem_instr class is removed from
   the example implementation. This type of record memory access is now done
   via the new vector support (see above).



4. Refinements to software breakpoints
======================================

* A SW-break instruction, putting the core in debug mode, may or may not
  decrement the PC after it has been executed. When it is not decremented (the
  PC will point to the instruction after the break), the PC decrement (to point
  to the instruction on which the software breakpoint is set) is done by the
  debug client, in the Checkers_pdc_interface class. Two requirements:

    - The PDC unit must be able to write to the PC (using the
      put_program_counter() member). For this purpose, PC write access has been
      added to the Tmicro example (making using of an indirect jump
      instruction).

    - In the PDC status register, there must be a sw_break mode bit, such that
      it is clear when a break instruction has been executed or not, and
      whether the PC must be adjusted or not.

  The scheme has to be selected in the pdc_commands.h by following two
  parameters:

        sw_break_enabled = 0,         // sw-breaks are supported or not
        sw_break_decrements_pc = 0    // a break instruction decrements the PC
                                      // or not

* Typically, a SW-break instruction is only inserted by the debug client, when
  the user sets software breakpoints. However, possibly, the initial program
  already contains SW-break instructions. In case a break instruction
  decrements the PC, the Checkers_pdc_interface will again increment the PC to
  avoid that you are stuck at this instruction.

  Note that in normal execution mode without debug client (like CA ISS), you
  never will get beyond a SW-break instruction when it decrements the PC.

* List of changes to pdc_commands class:

  - 'sw_break_enabled' is no longer a static member variable, but a named
    constant, and new parameter 'sw_break_decrements_pc':

     enum {
        sw_break_enabled = 0,
        sw_break_decrements_pc = 0
     };

  - extra member 'ocd_address_set' to invalidate the value in 'current_address'
    member on start-up or after reset_core().



5. Refinements to interaction interrupts
========================================

* Problem of interrupts arriving periodically in a debug session.

  When stopped at a (hardware or software) breakpoint, an interrupt becomes
  pending. After clicking the 'resume' button, the processor will typically
  start servicing the interrupt. Consequently, after the return from interrupt,
  you again hit the same breakpoint, and the next interrupt will become
  pending. So, you are in a dead-lock situation. Apparently, nothing changes
  when clicking resume.

* To avoid this dead-lock situation, we introduce a second step instruction in
  the pdc_commands class:

    void step(bool sync);          // current step, which can enter an ISR
    void step_dis_int(bool sync);  // new step, discarding interrupt requests

  In the Checkers_pdc_interface class, when stopped at a breakpoint, and doing
  a step or resume action, first a pdc_commands::step_dis_int() is done to get
  beyond the current breakpoint position in the code, followed by a normal
  resume (in case of resume).

* It is not needed to have both type of steps. An implementation can choose to
  never accepts interrupts during steps, or to only have a step function that
  always accepts interrupts. In these cases, you can give the both step
  functions the same definition.

* In our PDC hardware implementation (generated by Go tool), the behavior
  depends on the presence of the 'ocd_disable_interrupt' signal in nML. When
  this signal is defined, there are two step opcodes (DBG_STEP_INSTR and
  DBG_STEPDI_INSTR). Both steps lower the 'ocd_request' for two cycles, but the
  latter step also asserts the signal ocd_disable_interrupt during these
  cycles. In the PCU, you have to discard interrupt requests when this disable
  signal is set.

  When the 'ocd_disable_interrupt' signal is not defined, both step opcodes in
  pdc_opcodes.h have the same value (there is only one step which accepts
  interrupts).


List of changes to the pdc_commands interface:

 - The new Checkers_pdc_interface implementation assumes following pdc_commands
   member function to be present:

      void step_dis_int(bool sync);

   When the PDC unit has only one step opcode, this step function can be
   defined as follows:

      void step_dis_int(bool sync) { step(sync); }

   You can also implement such a step by temporarily disabling the interrupt
   enable mode bit.

This 'step_dis_int' function is now (nov-2011) also made available in the
Checkers_debugger interface, such that the debug client can call it explicitly
to avoid step-over/out problems in case of pending interrupts.



6. Multiprocessor synchronous stepping
======================================

In a multiprocessor implementation, there are several debug clients each
connected to a different processor. Via these debug clients, you can execute
local step/resume/request commands, which only affect the corresponding
processor. However, via the surrounding ChessMP GUI, you can send synchronous
step/resume/request commands to the connected processors. Actually, a
synchronous JTAG command is a single command (sent via one of the debug
clients) that is accepted by all the debug controllers that are connected to
the TAP controller. Care must be taken to avoid that such a synchronous
step/resume command would corrupt any processor. For example, assume that one
of the processors is stopped at a software breakpoint, then a synchronous
resume command should not arrive before the corresponding debug client has
handled the software breakpoint properly.

* Changes to the Checkers_debugger interface for synchronous stepping:

  - Added following new functions, intended for synchronous step/resume:

      enum Sync_start_status { ready, ready_after_step, at_break_after_step };

      Sync_status prepare_sync_command();
      void sync_step(bool sync =true);
      void sync_resume(bool sync =true);

    For synchronous step/resume commands, ChessMP will first send a
    prepare_sync_command() to all connected debug clients, followed by a
    sync_step or sync_resume command. The prepare command puts the processor in
    a clean state (e.g. when stopped at a software breakpoint, it will step
    over the software breakpoint, by temporarily switching the breakpoint and
    the original instruction), while the sync_step/resume sends a basic
    step/resume command to all connected processors.

  - Removed the 'bool sync' argument from the normal step/resume commands, as
    they are only applicable locally to a single processor:

      void step();
      void step_dis_int();
      void resume();

  - Added the possibility to have exported software breakpoints (extra export
    argument):

      int add_sw_break(unsigned pc, bool export_);

  It is sufficient to switch to the new Checkers_pdc_interface implementation,
  to deal with the above changes.

* Changes to the pdc_commands class interface:

  When switching to the new Checkers_pdc_interface implementation, following
  changes are needed to your pdc_commands class:

  - Introduce following typedef for software breakpoint instructions:

      typedef long long instr_type;

    Only in case the sw-break instruction would exceed 64-bit, you have
    to change this type.

  - In view of exported software breakpoints, the static public member
    core_sw_break_instr (and exported_sw_break_instr) is replaced by following
    public member function (mar-2012):

      instr_type sw_break_instr(bool export_, instr_type orig_instr);

    So, you have the possibility to return a different value dependent on the
    export argument and on the size of the original instruction to be replaced.

  - Add a string argument to following two functions:

      long long received_next_mem(string mem);
      long long received_next_reg(string reg);

    Typically, this argument is not used, but when needed, you have the option
    to differentiate based on the storage name (e.g. when reading out registers
    by moving them to memory, dependent on the width of the register, the
    number of memory words could be different).

* Changes to the Checkers_pdc_interface implementation:

  In our implementation we assume that the software-break instruction is a
  single-word instruction. To allow easy specialization in case this assumption
  is not valid, we introduced following protected virtual functions, which can
  be redefined in the <processor>_pdc_interface class:

      pdc_commands::instr_type get_instruction_at(unsigned pc);
      void put_instruction_at(unsigned pc, pdc_commands::instr_type);

  Our implemenation uses these two functions to replace instructions in PMEM
  for software breakpoints.

* Changes to the pdc_commands implementation:

  The <jtag_socket.h> API calls (jts_cmdbuf_add... calls), used to read from or
  write to the registers of the debug controller (PDC unit), are now behind the
  new abstract 'ocd_cable' interface, declared in ocd_cable.h.  This makes it
  easier to switch to a different protocol to interface with the same debug
  hardware.



7. Memory protections and multiple contexts
===========================================

* New functionality:

  - Memory protections:

    Peripheral devices can be mapped in the memory address space. Reading such
    an address can have side-effects, like popping a value from a stream
    buffer. So, you want to avoid that the debug client reads these memory
    addresses, only to visualize the memory contents in the GUI.

    Previously, the debug client had the "-u mask=<mask file>" option, where
    you could exclude (a range of) memory addresses from access. The debug
    client did never access these addresses on the hardware. When ChessDE asked
    the value of these addresses, a replacement value was returned instead.

    Now, this has been refined. The mask option has been replaced by the "Avoid
    reading memory ranges" debug setting in ChessDE. By default, ChessDE will
    never ask the value of these addresses, and instead display ?? in the
    memory view at the protected addresses. However, via the address context
    menu in ChessDE, you still have the option to do a forced hardware read at
    this specific address and to display the result. The value read is not
    cached.  When doing a next forced read, the address is read again on the
    hardware.

  - Multiple register contexts:
  
    This is linked to the nML property additional_register_contexts. In case of
    context_select_reg and context_shift_trn, the new Checkers_debugger
    get/put_context() functions access the active processor context. In case of
    context_issue_trn (or interleaved contexts), these functions access the
    OCD context register. The Core_status struct has an additional
    break_context member, storing the context which has hit a breakpoint
    (in case of interleaved contexts).

  - Refined watchpoint settings:

    To implement a watchpoint, it is possible now to use more than one PDC
    address register. In the generated PDC hardware unit this is needed as soon
    as you want to watch both writes and reads at an address, or when a memory
    can be accessed via multiple address buses.

* Changes to the Checkers_debugger interface

  Following functions were added:

 // protect memory address range [first,last] from redundant load access
    void protect_memory_at(std::string name, unsigned first, unsigned last);
    void clear_memory_protections();

 // multiple register contexts
    virtual int get_context();
    virtual int put_context(int);
    virtual Sync_start_status prepare_context_for_resume();

  It is sufficient to switch to the new Checkers_pdc_interface example
  implementation, to deal with the above changes.

  The protected ranges have the following impact on Checkers_pdc_interface:

    - When doing block-based memory access, it skips the protected addresses in
      the block.

    - It disables the cache functionality, when doing multiple reads from a
      protected address.

  Interleaved contexts have mainly impact on the get_status() member of
  Checkers_pdc_interface: it also retrieves the break context, and does the PC
  adaption after a software break in this break context.


* Changes to the pdc_commands class interface:

  When switching to the new Checkers_pdc_interface implementation, following
  watchpoint function has a different interface:

    int watch_supported(const Watchpoint_settings* ws) const;

  It returns the number of PDC address registers required to set a specific
  watchpoint. The watchpoint enable/disable functions obtain then a list of
  address register numbers:

    void enable_hw_break(const std::vector<int>&, const Watchpoint_settings*);
    void disable_hw_break(const std::vector<int>&);

  Following changes were introduced for multiple contexts:

   - enumerator constant 
       interleaved_contexts = <bool>
 
   - access to ocd_context_register (when interleaved_contexts is true) :
       int put_context(int);
       int get_context();
       int get_break_context();



8. Memory address step parameter
================================

 * The Checkers_pdc_interface get_memory_at() access functions request the
   memory values of an address range (cache-based read access). To deal with
   nML root memories having an address step larger than one, we introduced
   following member in the pdc_commands class:

       unsigned address_step(string mem); // address step of memory "mem"

   It is sufficient to add following member to pdc_commands, when upgrading the
   latest version of Checkers_pdc_interface:

       unsigned address_step(string) { return 1; }



9. Removed restrictions on address and data width
=================================================

Two top-level debugger interfaces are provided now in "checkers_debugger.h":

 - Checkers_debugger: the legacy interface where addresses are presented by
   unsigned (restricted to 32-bit) and data values are represented by long long
   (restricted to 64-bit).

 - Checkers_debugger64: the new interface where addresses are represented by
   "AddressType" (mapped to unsigned long long, restricted to 64-bit) and data
   values are represented by "DataType" (mapped to VBitWrapper, which supports
   arbitrary length integers and arithmetic).

   There is no change in the representation of vector element numbers and
   vector element ranges (they remain in terms of unsigned).

You choose one of these two interfaces by selecting the corresponding base
class in the definition of Checkers_pdc_interface class. For example, for the
Tmciro debug client:

   class Checkers_pdc_interface : public Checkers_debugger64 {
      ...
   };

For new debug clients, we advise the new interface, existing debug clients can
remain using the legacy interface.


Some smaller changes in pdc_caches.h:

 - Replaced c_array by std::array.
 - Introduced "arange" for address ranges.
 - write_merge_vline::flush(): removed redundant Checkers_pdc_interface
   argument.
