
// File generated by Go version O-2018.09#f5599cac26#190121, Tue May 28 10:45:21 2024
// Copyright 2014-2018 Synopsys, Inc. All rights reserved.

HW conflicts on transitories of tmicro


<<<< Enable option -s to see instruction patterns (may be slow). >>>>


<<<< Enable debug mode (option -d1) to see HW conflicts between
     operations with different 'strength'. >>>>


<<<< Enable option -n to obtain an nML rule derivation for each source reference (may be slow). >>>>


<<<< Enable option -v to obtain all source references for each conflict (may be slow). >>>>



ocd_addr_r stage 1 : conflict for
		<option -s prints instruction bit pattern here (may be slow)>
  ocd_addr_r_rd_ocd_addr_ocd_ld_DM_ID_alw  : IN( ocd_addr `ID` ) GRD( ocd_ld_DM `ID` ) OUT( ocd_addr_r `ID` )
  <---> 
  ocd_addr_r_rd_ocd_addr_ocd_st_DM_ID_alw  : IN( ocd_addr `ID` ) GRD( ocd_st_DM `ID` ) OUT( ocd_addr_r `ID` )

	------------------------------------------------------------
	This hardware conflict is non-existent if the (different)
	GUARD CONDITIONS of both operations are mutually exclusive.
	------------------------------------------------------------

      source code reference for conflict
      [ocd_if.n:28] ocd_data `E1` = dm_read `E1` = (ocd_if.n:28) DM[dm_addr `ID` = ocd_addr_r = ocd_addr `ID`] `ID`;
        <>
      [ocd_if.n:32] dm_addr_pipe `ID` = ocd_addr_r `ID` = ocd_addr `ID`;


      (refined) source code reference for conflict
      [ocd_if.n:28] dm_addr `ID` = ocd_addr_r = ocd_addr `ID`
        <>
      [ocd_if.n:32] dm_addr_pipe `ID` = ocd_addr_r `ID` = ocd_addr `ID`


ocd_addr_r stage 1 : conflict for
		<option -s prints instruction bit pattern here (may be slow)>
  ocd_addr_r_rd_ocd_addr_ocd_ld_DM_ID_alw  : IN( ocd_addr `ID` ) GRD( ocd_ld_DM `ID` ) OUT( ocd_addr_r `ID` )
  <---> 
  ocd_addr_r_rd_ocd_addr_ocd_ld_PM_ID_alw  : IN( ocd_addr `ID` ) GRD( ocd_ld_PM `ID` ) OUT( ocd_addr_r `ID` )

	------------------------------------------------------------
	This hardware conflict is non-existent if the (different)
	GUARD CONDITIONS of both operations are mutually exclusive.
	------------------------------------------------------------

      source code reference for conflict
      [ocd_if.n:28] ocd_data `E1` = dm_read `E1` = (ocd_if.n:28) DM[dm_addr `ID` = ocd_addr_r = ocd_addr `ID`] `ID`;
        <>
      [ocd_if.n:40] ocd_instr `E1` = pm_read `E1` = (ocd_if.n:40) PM[pm_addr `ID` = ocd_addr_r = ocd_addr `ID`] `ID`;


      (refined) source code reference for conflict
      [ocd_if.n:28] dm_addr `ID` = ocd_addr_r = ocd_addr `ID`
        <>
      [ocd_if.n:40] pm_addr `ID` = ocd_addr_r = ocd_addr `ID`


ocd_addr_r stage 1 : conflict for
		<option -s prints instruction bit pattern here (may be slow)>
  ocd_addr_r_rd_ocd_addr_ocd_ld_DM_ID_alw  : IN( ocd_addr `ID` ) GRD( ocd_ld_DM `ID` ) OUT( ocd_addr_r `ID` )
  <---> 
  ocd_addr_r_rd_ocd_addr_ocd_st_PM_ID_alw  : IN( ocd_addr `ID` ) GRD( ocd_st_PM `ID` ) OUT( ocd_addr_r `ID` )

	------------------------------------------------------------
	This hardware conflict is non-existent if the (different)
	GUARD CONDITIONS of both operations are mutually exclusive.
	------------------------------------------------------------

      source code reference for conflict
      [ocd_if.n:28] ocd_data `E1` = dm_read `E1` = (ocd_if.n:28) DM[dm_addr `ID` = ocd_addr_r = ocd_addr `ID`] `ID`;
        <>
      [ocd_if.n:44] pm_addr_pipe `ID` = ocd_addr_r `ID` = ocd_addr `ID`;


      (refined) source code reference for conflict
      [ocd_if.n:28] dm_addr `ID` = ocd_addr_r = ocd_addr `ID`
        <>
      [ocd_if.n:44] pm_addr_pipe `ID` = ocd_addr_r `ID` = ocd_addr `ID`


ocd_addr_r stage 1 : conflict for
		<option -s prints instruction bit pattern here (may be slow)>
  ocd_addr_r_rd_ocd_addr_ocd_ld_DM_ID_alw  : IN( ocd_addr `ID` ) GRD( ocd_ld_DM `ID` ) OUT( ocd_addr_r `ID` )
  <---> 
  ocd_addr_r_rd_ocd_addr_ocd_incr_addr_alw  : IN( ocd_addr) GRD( ocd_incr_addr) OUT( ocd_addr_r)

	------------------------------------------------------------
	This hardware conflict is non-existent if the (different)
	GUARD CONDITIONS of both operations are mutually exclusive.
	------------------------------------------------------------

      source code reference for conflict
      [ocd_if.n:28] ocd_data `E1` = dm_read `E1` = (ocd_if.n:28) DM[dm_addr `ID` = ocd_addr_r = ocd_addr `ID`] `ID`;
        <>
      [ocd_if.n:23] ocd_addr = ocd_addr_w = incr (ocd_addr_r = ocd_addr)  @ocd_addr_incr;


      (refined) source code reference for conflict
      [ocd_if.n:28] dm_addr `ID` = ocd_addr_r = ocd_addr `ID`
        <>
      [ocd_if.n:23] ocd_addr_r = ocd_addr


ocd_addr_r stage 1 : conflict for
		<option -s prints instruction bit pattern here (may be slow)>
  ocd_addr_r_rd_ocd_addr_ocd_st_DM_ID_alw  : IN( ocd_addr `ID` ) GRD( ocd_st_DM `ID` ) OUT( ocd_addr_r `ID` )
  <---> 
  ocd_addr_r_rd_ocd_addr_ocd_ld_PM_ID_alw  : IN( ocd_addr `ID` ) GRD( ocd_ld_PM `ID` ) OUT( ocd_addr_r `ID` )

	------------------------------------------------------------
	This hardware conflict is non-existent if the (different)
	GUARD CONDITIONS of both operations are mutually exclusive.
	------------------------------------------------------------

      source code reference for conflict
      [ocd_if.n:32] dm_addr_pipe `ID` = ocd_addr_r `ID` = ocd_addr `ID`;
        <>
      [ocd_if.n:40] ocd_instr `E1` = pm_read `E1` = (ocd_if.n:40) PM[pm_addr `ID` = ocd_addr_r = ocd_addr `ID`] `ID`;


      (refined) source code reference for conflict
      [ocd_if.n:32] dm_addr_pipe `ID` = ocd_addr_r `ID` = ocd_addr `ID`
        <>
      [ocd_if.n:40] pm_addr `ID` = ocd_addr_r = ocd_addr `ID`


ocd_addr_r stage 1 : conflict for
		<option -s prints instruction bit pattern here (may be slow)>
  ocd_addr_r_rd_ocd_addr_ocd_st_DM_ID_alw  : IN( ocd_addr `ID` ) GRD( ocd_st_DM `ID` ) OUT( ocd_addr_r `ID` )
  <---> 
  ocd_addr_r_rd_ocd_addr_ocd_st_PM_ID_alw  : IN( ocd_addr `ID` ) GRD( ocd_st_PM `ID` ) OUT( ocd_addr_r `ID` )

	------------------------------------------------------------
	This hardware conflict is non-existent if the (different)
	GUARD CONDITIONS of both operations are mutually exclusive.
	------------------------------------------------------------

      source code reference for conflict
      [ocd_if.n:32] dm_addr_pipe `ID` = ocd_addr_r `ID` = ocd_addr `ID`;
        <>
      [ocd_if.n:44] pm_addr_pipe `ID` = ocd_addr_r `ID` = ocd_addr `ID`;


      (refined) source code reference for conflict
      [ocd_if.n:32] dm_addr_pipe `ID` = ocd_addr_r `ID` = ocd_addr `ID`
        <>
      [ocd_if.n:44] pm_addr_pipe `ID` = ocd_addr_r `ID` = ocd_addr `ID`


ocd_addr_r stage 1 : conflict for
		<option -s prints instruction bit pattern here (may be slow)>
  ocd_addr_r_rd_ocd_addr_ocd_st_DM_ID_alw  : IN( ocd_addr `ID` ) GRD( ocd_st_DM `ID` ) OUT( ocd_addr_r `ID` )
  <---> 
  ocd_addr_r_rd_ocd_addr_ocd_incr_addr_alw  : IN( ocd_addr) GRD( ocd_incr_addr) OUT( ocd_addr_r)

	------------------------------------------------------------
	This hardware conflict is non-existent if the (different)
	GUARD CONDITIONS of both operations are mutually exclusive.
	------------------------------------------------------------

      source code reference for conflict
      [ocd_if.n:32] dm_addr_pipe `ID` = ocd_addr_r `ID` = ocd_addr `ID`;
        <>
      [ocd_if.n:23] ocd_addr = ocd_addr_w = incr (ocd_addr_r = ocd_addr)  @ocd_addr_incr;


      (refined) source code reference for conflict
      [ocd_if.n:32] dm_addr_pipe `ID` = ocd_addr_r `ID` = ocd_addr `ID`
        <>
      [ocd_if.n:23] ocd_addr_r = ocd_addr


ocd_addr_r stage 1 : conflict for
		<option -s prints instruction bit pattern here (may be slow)>
  ocd_addr_r_rd_ocd_addr_ocd_ld_PM_ID_alw  : IN( ocd_addr `ID` ) GRD( ocd_ld_PM `ID` ) OUT( ocd_addr_r `ID` )
  <---> 
  ocd_addr_r_rd_ocd_addr_ocd_st_PM_ID_alw  : IN( ocd_addr `ID` ) GRD( ocd_st_PM `ID` ) OUT( ocd_addr_r `ID` )

	------------------------------------------------------------
	This hardware conflict is non-existent if the (different)
	GUARD CONDITIONS of both operations are mutually exclusive.
	------------------------------------------------------------

      source code reference for conflict
      [ocd_if.n:40] ocd_instr `E1` = pm_read `E1` = (ocd_if.n:40) PM[pm_addr `ID` = ocd_addr_r = ocd_addr `ID`] `ID`;
        <>
      [ocd_if.n:44] pm_addr_pipe `ID` = ocd_addr_r `ID` = ocd_addr `ID`;


      (refined) source code reference for conflict
      [ocd_if.n:40] pm_addr `ID` = ocd_addr_r = ocd_addr `ID`
        <>
      [ocd_if.n:44] pm_addr_pipe `ID` = ocd_addr_r `ID` = ocd_addr `ID`


ocd_addr_r stage 1 : conflict for
		<option -s prints instruction bit pattern here (may be slow)>
  ocd_addr_r_rd_ocd_addr_ocd_ld_PM_ID_alw  : IN( ocd_addr `ID` ) GRD( ocd_ld_PM `ID` ) OUT( ocd_addr_r `ID` )
  <---> 
  ocd_addr_r_rd_ocd_addr_ocd_incr_addr_alw  : IN( ocd_addr) GRD( ocd_incr_addr) OUT( ocd_addr_r)

	------------------------------------------------------------
	This hardware conflict is non-existent if the (different)
	GUARD CONDITIONS of both operations are mutually exclusive.
	------------------------------------------------------------

      source code reference for conflict
      [ocd_if.n:40] ocd_instr `E1` = pm_read `E1` = (ocd_if.n:40) PM[pm_addr `ID` = ocd_addr_r = ocd_addr `ID`] `ID`;
        <>
      [ocd_if.n:23] ocd_addr = ocd_addr_w = incr (ocd_addr_r = ocd_addr)  @ocd_addr_incr;


      (refined) source code reference for conflict
      [ocd_if.n:40] pm_addr `ID` = ocd_addr_r = ocd_addr `ID`
        <>
      [ocd_if.n:23] ocd_addr_r = ocd_addr


ocd_addr_r stage 1 : conflict for
		<option -s prints instruction bit pattern here (may be slow)>
  ocd_addr_r_rd_ocd_addr_ocd_st_PM_ID_alw  : IN( ocd_addr `ID` ) GRD( ocd_st_PM `ID` ) OUT( ocd_addr_r `ID` )
  <---> 
  ocd_addr_r_rd_ocd_addr_ocd_incr_addr_alw  : IN( ocd_addr) GRD( ocd_incr_addr) OUT( ocd_addr_r)

	------------------------------------------------------------
	This hardware conflict is non-existent if the (different)
	GUARD CONDITIONS of both operations are mutually exclusive.
	------------------------------------------------------------

      source code reference for conflict
      [ocd_if.n:44] pm_addr_pipe `ID` = ocd_addr_r `ID` = ocd_addr `ID`;
        <>
      [ocd_if.n:23] ocd_addr = ocd_addr_w = incr (ocd_addr_r = ocd_addr)  @ocd_addr_incr;


      (refined) source code reference for conflict
      [ocd_if.n:44] pm_addr_pipe `ID` = ocd_addr_r `ID` = ocd_addr `ID`
        <>
      [ocd_if.n:23] ocd_addr_r = ocd_addr


dm_write stage 2 : conflict for
		<option -s prints instruction bit pattern here (may be slow)>
  dm_write_copy0_rse1_E1  : IN( rse1 `E1` ) OUT( dm_write `E1` )
  <---> 
  dm_write_rd_ocd_data___ocd_st_DME1_r_E1_alw  : IN( ocd_data `E1` ) GRD( __ocd_st_DME1_r `E1` ) OUT( dm_write `E1` )


      source code reference for conflict
      [load_store.n:57] DM[dm_addr] `E1` = dm_write `E1` = rr `E1`;
        <>
      [ocd_if.n:34] DM[dm_addr = dm_addr_pipe] `E1` = dm_write `E1` = ocd_data `E1`;


      (refined) source code reference for conflict
      [tmicro.n:125] (load_store.n:57) dm_write `E1` = rse1 = R[r]
        <>
      [ocd_if.n:34] DM[dm_addr = dm_addr_pipe] `E1` = dm_write `E1` = ocd_data `E1`


dm_write stage 2 : conflict for
		<option -s prints instruction bit pattern here (may be slow)>
  dm_write_rd_SP_E1  : IN( SP `E1` ) OUT( dm_write `E1` )
  <---> 
  dm_write_rd_ocd_data___ocd_st_DME1_r_E1_alw  : IN( ocd_data `E1` ) GRD( __ocd_st_DME1_r `E1` ) OUT( dm_write `E1` )


      source code reference for conflict
      [load_store.n:57] DM[dm_addr] `E1` = dm_write `E1` = rr `E1`;
        <>
      [ocd_if.n:34] DM[dm_addr = dm_addr_pipe] `E1` = dm_write `E1` = ocd_data `E1`;


      (refined) source code reference for conflict
      [tmicro.n:130] (load_store.n:57) dm_write `E1` = SP
        <>
      [ocd_if.n:34] DM[dm_addr = dm_addr_pipe] `E1` = dm_write `E1` = ocd_data `E1`


dm_write stage 2 : conflict for
		<option -s prints instruction bit pattern here (may be slow)>
  dm_write_rd_LR_E1  : IN( LR `E1` ) OUT( dm_write `E1` )
  <---> 
  dm_write_rd_ocd_data___ocd_st_DME1_r_E1_alw  : IN( ocd_data `E1` ) GRD( __ocd_st_DME1_r `E1` ) OUT( dm_write `E1` )


      source code reference for conflict
      [load_store.n:57] DM[dm_addr] `E1` = dm_write `E1` = rr `E1`;
        <>
      [ocd_if.n:34] DM[dm_addr = dm_addr_pipe] `E1` = dm_write `E1` = ocd_data `E1`;


      (refined) source code reference for conflict
      [tmicro.n:131] (load_store.n:57) dm_write `E1` = LR
        <>
      [ocd_if.n:34] DM[dm_addr = dm_addr_pipe] `E1` = dm_write `E1` = ocd_data `E1`


dm_write stage 2 : conflict for
		<option -s prints instruction bit pattern here (may be slow)>
  dm_write_rd_SR_E1  : IN( SR `E1` ) OUT( dm_write `E1` )
  <---> 
  dm_write_rd_ocd_data___ocd_st_DME1_r_E1_alw  : IN( ocd_data `E1` ) GRD( __ocd_st_DME1_r `E1` ) OUT( dm_write `E1` )


      source code reference for conflict
      [load_store.n:57] DM[dm_addr] `E1` = dm_write `E1` = rr `E1`;
        <>
      [ocd_if.n:34] DM[dm_addr = dm_addr_pipe] `E1` = dm_write `E1` = ocd_data `E1`;


      (refined) source code reference for conflict
      [tmicro.n:132] (load_store.n:57) dm_write `E1` = SR
        <>
      [ocd_if.n:34] DM[dm_addr = dm_addr_pipe] `E1` = dm_write `E1` = ocd_data `E1`


dm_write stage 2 : conflict for
		<option -s prints instruction bit pattern here (may be slow)>
  dm_write_rd_ILR_E1  : IN( ILR `E1` ) OUT( dm_write `E1` )
  <---> 
  dm_write_rd_ocd_data___ocd_st_DME1_r_E1_alw  : IN( ocd_data `E1` ) GRD( __ocd_st_DME1_r `E1` ) OUT( dm_write `E1` )


      source code reference for conflict
      [load_store.n:57] DM[dm_addr] `E1` = dm_write `E1` = rr `E1`;
        <>
      [ocd_if.n:34] DM[dm_addr = dm_addr_pipe] `E1` = dm_write `E1` = ocd_data `E1`;


      (refined) source code reference for conflict
      [tmicro.n:134] (load_store.n:57) dm_write `E1` = ILR
        <>
      [ocd_if.n:34] DM[dm_addr = dm_addr_pipe] `E1` = dm_write `E1` = ocd_data `E1`


dm_write stage 2 : conflict for
		<option -s prints instruction bit pattern here (may be slow)>
  dm_write_rd_ISR_E1  : IN( ISR `E1` ) OUT( dm_write `E1` )
  <---> 
  dm_write_rd_ocd_data___ocd_st_DME1_r_E1_alw  : IN( ocd_data `E1` ) GRD( __ocd_st_DME1_r `E1` ) OUT( dm_write `E1` )


      source code reference for conflict
      [load_store.n:57] DM[dm_addr] `E1` = dm_write `E1` = rr `E1`;
        <>
      [ocd_if.n:34] DM[dm_addr = dm_addr_pipe] `E1` = dm_write `E1` = ocd_data `E1`;


      (refined) source code reference for conflict
      [tmicro.n:135] (load_store.n:57) dm_write `E1` = ISR
        <>
      [ocd_if.n:34] DM[dm_addr = dm_addr_pipe] `E1` = dm_write `E1` = ocd_data `E1`


dm_addr stage 1 : conflict for
		<option -s prints instruction bit pattern here (may be slow)>
  dm_addr_copy0_ag1q_ID  : IN( ag1q `ID` ) OUT( dm_addr `ID` )
  <---> 
  dm_addr_copy0_ocd_addr_r_ocd_ld_DM_ID_alw  : IN( ocd_addr_r `ID` ) GRD( ocd_ld_DM `ID` ) OUT( dm_addr `ID` )


      source code reference for conflict
      [load_store.n:50] dm_addr `ID` = ag1q `ID`;
        <>
      [ocd_if.n:28] ocd_data `E1` = dm_read `E1` = (ocd_if.n:28) DM[dm_addr `ID` = ocd_addr_r = ocd_addr `ID`] `ID`;


      (refined) source code reference for conflict
      [load_store.n:50] dm_addr `ID` = ag1q `ID`
        <>
      [ocd_if.n:28] dm_addr `ID` = ocd_addr_r = ocd_addr `ID`


dm_addr stage 1 : conflict for
		<option -s prints instruction bit pattern here (may be slow)>
  dm_addr_copy0_ag1p_ID  : IN( ag1p `ID` ) OUT( dm_addr `ID` )
  <---> 
  dm_addr_copy0_ocd_addr_r_ocd_ld_DM_ID_alw  : IN( ocd_addr_r `ID` ) GRD( ocd_ld_DM `ID` ) OUT( dm_addr `ID` )


      source code reference for conflict
      [load_store.n:92] dm_addr `ID` = ag1p `ID`;
        <>
      [ocd_if.n:28] ocd_data `E1` = dm_read `E1` = (ocd_if.n:28) DM[dm_addr `ID` = ocd_addr_r = ocd_addr `ID`] `ID`;


      (refined) source code reference for conflict
      [load_store.n:92] dm_addr `ID` = ag1p `ID`
        <>
      [ocd_if.n:28] dm_addr `ID` = ocd_addr_r = ocd_addr `ID`


dm_addr stage 2 : conflict for
		<option -s prints instruction bit pattern here (may be slow)>
  dm_addr_copy0_dm_addr_pipe_E1  : IN( __dm_addr_pipe_r `E1` ) OUT( dm_addr `E1` )
  <---> 
  dm_addr_copy0_dm_addr_pipe___ocd_st_DME1_r_E1_alw  : IN( __dm_addr_pipe_r `E1` ) GRD( __ocd_st_DME1_r `E1` ) OUT( dm_addr `E1` )


      source code reference for conflict
      [load_store.n:56] dm_addr `E1` = dm_addr_pipe `E1`;
        <>
      [ocd_if.n:34] DM[dm_addr = dm_addr_pipe] `E1` = dm_write `E1` = ocd_data `E1`;


      (refined) source code reference for conflict
      [load_store.n:56] dm_addr `E1` = dm_addr_pipe `E1`
        <>
      [ocd_if.n:34] dm_addr = dm_addr_pipe


dm_read stage 2 : conflict for
		<option -s prints instruction bit pattern here (may be slow)>
  dm_read_ld_DM_dm_addr_ID  : IN( DM `ID` dm_addr `ID` ) OUT( dm_read `E1` )
  <---> 
  dm_read_ld_DM_dm_addr_ocd_ld_DM_ID_alw  : IN( DM `ID` dm_addr `ID` ) GRD( ocd_ld_DM `ID` ) OUT( dm_read `E1` )


      source code reference for conflict
      [load_store.n:51] rr `E1` = dm_read `E1` = DM[dm_addr `ID`] `ID`;
        <>
      [ocd_if.n:28] ocd_data `E1` = dm_read `E1` = (ocd_if.n:28) DM[dm_addr `ID` = ocd_addr_r = ocd_addr `ID`] `ID`;


      (refined) source code reference for conflict
      [load_store.n:51] rr `E1` = dm_read `E1` = DM[dm_addr `ID`] `ID`
        <>
      [ocd_if.n:27] ocd_data `E1` = dm_read `E1` = (ocd_if.n:28) DM[dm_addr `ID` = ocd_addr_r = ocd_addr `ID`] `ID`


pm_write stage 2 : conflict for
		<option -s prints instruction bit pattern here (may be slow)>
  pm_write_copy0_rse1_E1  : IN( rse1 `E1` ) OUT( pm_write `E1` )
  <---> 
  pm_write_rd_ocd_instr___ocd_st_PME1_r_E1_alw  : IN( ocd_instr `E1` ) GRD( __ocd_st_PME1_r `E1` ) OUT( pm_write `E1` )


      source code reference for conflict
      [load_store.n:130] PM[pm_addr] `E1` = pm_write `E1` = rr `E1`;
        <>
      [ocd_if.n:46] PM[pm_addr = pm_addr_pipe] `E1` = pm_write `E1` = ocd_instr `E1`;


      (refined) source code reference for conflict
      [tmicro.n:125] (load_store.n:130) pm_write `E1` = rse1 = R[r]
        <>
      [ocd_if.n:46] PM[pm_addr = pm_addr_pipe] `E1` = pm_write `E1` = ocd_instr `E1`


pm_write stage 2 : conflict for
		<option -s prints instruction bit pattern here (may be slow)>
  pm_write_copy0___pm_write_r_SP_E1  : IN( __pm_write_r_SP `E1` ) OUT( pm_write `E1` )
  <---> 
  pm_write_rd_ocd_instr___ocd_st_PME1_r_E1_alw  : IN( ocd_instr `E1` ) GRD( __ocd_st_PME1_r `E1` ) OUT( pm_write `E1` )


      source code reference for conflict
      [load_store.n:130] PM[pm_addr] `E1` = pm_write `E1` = rr `E1`;
        <>
      [ocd_if.n:46] PM[pm_addr = pm_addr_pipe] `E1` = pm_write `E1` = ocd_instr `E1`;


      (refined) source code reference for conflict
      [tmicro.n:130] (load_store.n:130) pm_write `E1` = __pm_write_r_SP `E1` = SP
        <>
      [ocd_if.n:46] PM[pm_addr = pm_addr_pipe] `E1` = pm_write `E1` = ocd_instr `E1`


pm_write stage 2 : conflict for
		<option -s prints instruction bit pattern here (may be slow)>
  pm_write_copy0___pm_write_r_LR_E1  : IN( __pm_write_r_LR `E1` ) OUT( pm_write `E1` )
  <---> 
  pm_write_rd_ocd_instr___ocd_st_PME1_r_E1_alw  : IN( ocd_instr `E1` ) GRD( __ocd_st_PME1_r `E1` ) OUT( pm_write `E1` )


      source code reference for conflict
      [load_store.n:130] PM[pm_addr] `E1` = pm_write `E1` = rr `E1`;
        <>
      [ocd_if.n:46] PM[pm_addr = pm_addr_pipe] `E1` = pm_write `E1` = ocd_instr `E1`;


      (refined) source code reference for conflict
      [tmicro.n:131] (load_store.n:130) pm_write `E1` = __pm_write_r_LR `E1` = LR
        <>
      [ocd_if.n:46] PM[pm_addr = pm_addr_pipe] `E1` = pm_write `E1` = ocd_instr `E1`


pm_write stage 2 : conflict for
		<option -s prints instruction bit pattern here (may be slow)>
  pm_write_copy0___pm_write_r_SR_E1  : IN( __pm_write_r_SR `E1` ) OUT( pm_write `E1` )
  <---> 
  pm_write_rd_ocd_instr___ocd_st_PME1_r_E1_alw  : IN( ocd_instr `E1` ) GRD( __ocd_st_PME1_r `E1` ) OUT( pm_write `E1` )


      source code reference for conflict
      [load_store.n:130] PM[pm_addr] `E1` = pm_write `E1` = rr `E1`;
        <>
      [ocd_if.n:46] PM[pm_addr = pm_addr_pipe] `E1` = pm_write `E1` = ocd_instr `E1`;


      (refined) source code reference for conflict
      [tmicro.n:132] (load_store.n:130) pm_write `E1` = __pm_write_r_SR `E1` = SR
        <>
      [ocd_if.n:46] PM[pm_addr = pm_addr_pipe] `E1` = pm_write `E1` = ocd_instr `E1`


pm_write stage 2 : conflict for
		<option -s prints instruction bit pattern here (may be slow)>
  pm_write_copy0___pm_write_r_ILR_E1  : IN( __pm_write_r_ILR `E1` ) OUT( pm_write `E1` )
  <---> 
  pm_write_rd_ocd_instr___ocd_st_PME1_r_E1_alw  : IN( ocd_instr `E1` ) GRD( __ocd_st_PME1_r `E1` ) OUT( pm_write `E1` )


      source code reference for conflict
      [load_store.n:130] PM[pm_addr] `E1` = pm_write `E1` = rr `E1`;
        <>
      [ocd_if.n:46] PM[pm_addr = pm_addr_pipe] `E1` = pm_write `E1` = ocd_instr `E1`;


      (refined) source code reference for conflict
      [tmicro.n:134] (load_store.n:130) pm_write `E1` = __pm_write_r_ILR `E1` = ILR
        <>
      [ocd_if.n:46] PM[pm_addr = pm_addr_pipe] `E1` = pm_write `E1` = ocd_instr `E1`


pm_write stage 2 : conflict for
		<option -s prints instruction bit pattern here (may be slow)>
  pm_write_copy0___pm_write_r_ISR_E1  : IN( __pm_write_r_ISR `E1` ) OUT( pm_write `E1` )
  <---> 
  pm_write_rd_ocd_instr___ocd_st_PME1_r_E1_alw  : IN( ocd_instr `E1` ) GRD( __ocd_st_PME1_r `E1` ) OUT( pm_write `E1` )


      source code reference for conflict
      [load_store.n:130] PM[pm_addr] `E1` = pm_write `E1` = rr `E1`;
        <>
      [ocd_if.n:46] PM[pm_addr = pm_addr_pipe] `E1` = pm_write `E1` = ocd_instr `E1`;


      (refined) source code reference for conflict
      [tmicro.n:135] (load_store.n:130) pm_write `E1` = __pm_write_r_ISR `E1` = ISR
        <>
      [ocd_if.n:46] PM[pm_addr = pm_addr_pipe] `E1` = pm_write `E1` = ocd_instr `E1`


pm_addr stage 1 : conflict for
		<option -s prints instruction bit pattern here (may be slow)>
  pm_addr_copy0_ag1p_ID  : IN( ag1p `ID` ) OUT( pm_addr `ID` )
  <---> 
  pm_addr_copy0_ocd_addr_r_ocd_ld_PM_ID_alw  : IN( ocd_addr_r `ID` ) GRD( ocd_ld_PM `ID` ) OUT( pm_addr `ID` )


      source code reference for conflict
      [load_store.n:115] pm_addr `ID` = ag1p `ID`;
        <>
      [ocd_if.n:40] ocd_instr `E1` = pm_read `E1` = (ocd_if.n:40) PM[pm_addr `ID` = ocd_addr_r = ocd_addr `ID`] `ID`;


      (refined) source code reference for conflict
      [load_store.n:115] pm_addr `ID` = ag1p `ID`
        <>
      [ocd_if.n:40] pm_addr `ID` = ocd_addr_r = ocd_addr `ID`


pm_addr stage 2 : conflict for
		<option -s prints instruction bit pattern here (may be slow)>
  pm_addr_copy0_pm_addr_pipe_E1  : IN( __pm_addr_pipe_r `E1` ) OUT( pm_addr `E1` )
  <---> 
  pm_addr_copy0_pm_addr_pipe___ocd_st_PME1_r_E1_alw  : IN( __pm_addr_pipe_r `E1` ) GRD( __ocd_st_PME1_r `E1` ) OUT( pm_addr `E1` )


      source code reference for conflict
      [load_store.n:129] pm_addr `E1` = pm_addr_pipe `E1`;
        <>
      [ocd_if.n:46] PM[pm_addr = pm_addr_pipe] `E1` = pm_write `E1` = ocd_instr `E1`;


      (refined) source code reference for conflict
      [load_store.n:129] pm_addr `E1` = pm_addr_pipe `E1`
        <>
      [ocd_if.n:46] pm_addr = pm_addr_pipe


pm_read stage 2 : conflict for
		<option -s prints instruction bit pattern here (may be slow)>
  pm_read_ld_PM_pm_addr_ID  : IN( PM `ID` pm_addr `ID` ) OUT( pm_read `E1` )
  <---> 
  pm_read_ld_PM_pm_addr_ocd_ld_PM_ID_alw  : IN( PM `ID` pm_addr `ID` ) GRD( ocd_ld_PM `ID` ) OUT( pm_read `E1` )


      source code reference for conflict
      [load_store.n:116] rr `E1` = pm_read `E1` = PM[pm_addr `ID`] `ID`;
        <>
      [ocd_if.n:40] ocd_instr `E1` = pm_read `E1` = (ocd_if.n:40) PM[pm_addr `ID` = ocd_addr_r = ocd_addr `ID`] `ID`;


      (refined) source code reference for conflict
      [load_store.n:116] rr `E1` = pm_read `E1` = PM[pm_addr `ID`] `ID`
        <>
      [ocd_if.n:39] ocd_instr `E1` = pm_read `E1` = (ocd_if.n:40) PM[pm_addr `ID` = ocd_addr_r = ocd_addr `ID`] `ID`


__dm_addr_pipe_w stage 1 : conflict for
		<option -s prints instruction bit pattern here (may be slow)>
  dm_addr_pipe_copy0_ag1q_ID  : IN( ag1q `ID` ) OUT( __dm_addr_pipe_w `ID` )
  <---> 
  dm_addr_pipe_copy0_ocd_addr_r_ocd_st_DM_ID_alw  : IN( ocd_addr_r `ID` ) GRD( ocd_st_DM `ID` ) OUT( __dm_addr_pipe_w `ID` )


      source code reference for conflict
      [load_store.n:54] dm_addr_pipe `ID` = ag1q `ID`;
        <>
      [ocd_if.n:32] dm_addr_pipe `ID` = ocd_addr_r `ID` = ocd_addr `ID`;


      (refined) source code reference for conflict
      [load_store.n:54] dm_addr_pipe `ID` = ag1q `ID`
        <>
      [ocd_if.n:32] dm_addr_pipe `ID` = ocd_addr_r `ID` = ocd_addr `ID`


__dm_addr_pipe_w stage 1 : conflict for
		<option -s prints instruction bit pattern here (may be slow)>
  dm_addr_pipe_copy0_ag1p_ID  : IN( ag1p `ID` ) OUT( __dm_addr_pipe_w `ID` )
  <---> 
  dm_addr_pipe_copy0_ocd_addr_r_ocd_st_DM_ID_alw  : IN( ocd_addr_r `ID` ) GRD( ocd_st_DM `ID` ) OUT( __dm_addr_pipe_w `ID` )


      source code reference for conflict
      [load_store.n:96] dm_addr_pipe `ID` = ag1p `ID`;
        <>
      [ocd_if.n:32] dm_addr_pipe `ID` = ocd_addr_r `ID` = ocd_addr `ID`;


      (refined) source code reference for conflict
      [load_store.n:96] dm_addr_pipe `ID` = ag1p `ID`
        <>
      [ocd_if.n:32] dm_addr_pipe `ID` = ocd_addr_r `ID` = ocd_addr `ID`


__dm_addr_pipe_r stage 2 : conflict for
		<option -s prints instruction bit pattern here (may be slow)>
  _pipe_dm_addr_pipe_ID  : IN( __dm_addr_pipe_w `ID` ) OUT( __dm_addr_pipe_r `E1` )
  <---> 
  _pipe_dm_addr_pipe_ocd_st_DM_ID_alw  : IN( __dm_addr_pipe_w `ID` ) GRD( ocd_st_DM `ID` ) OUT( __dm_addr_pipe_r `E1` )


      source code reference for conflict
      [load_store.n:54] dm_addr_pipe `ID` = ag1q `ID`;
        <>
      [ocd_if.n:32] dm_addr_pipe `ID` = ocd_addr_r `ID` = ocd_addr `ID`;


      (refined) source code reference for conflict
      [load_store.n:54] dm_addr_pipe `ID` = ag1q `ID`
        <>
      [ocd_if.n:32] dm_addr_pipe `ID` = ocd_addr_r `ID` = ocd_addr `ID`


__pm_addr_pipe_w stage 1 : conflict for
		<option -s prints instruction bit pattern here (may be slow)>
  pm_addr_pipe_copy0_ag1p_ID  : IN( ag1p `ID` ) OUT( __pm_addr_pipe_w `ID` )
  <---> 
  pm_addr_pipe_copy0_ocd_addr_r_ocd_st_PM_ID_alw  : IN( ocd_addr_r `ID` ) GRD( ocd_st_PM `ID` ) OUT( __pm_addr_pipe_w `ID` )


      source code reference for conflict
      [load_store.n:127] pm_addr_pipe `ID` = ag1p `ID`;
        <>
      [ocd_if.n:44] pm_addr_pipe `ID` = ocd_addr_r `ID` = ocd_addr `ID`;


      (refined) source code reference for conflict
      [load_store.n:127] pm_addr_pipe `ID` = ag1p `ID`
        <>
      [ocd_if.n:44] pm_addr_pipe `ID` = ocd_addr_r `ID` = ocd_addr `ID`


__pm_addr_pipe_r stage 2 : conflict for
		<option -s prints instruction bit pattern here (may be slow)>
  _pipe_pm_addr_pipe_ID  : IN( __pm_addr_pipe_w `ID` ) OUT( __pm_addr_pipe_r `E1` )
  <---> 
  _pipe_pm_addr_pipe_ocd_st_PM_ID_alw  : IN( __pm_addr_pipe_w `ID` ) GRD( ocd_st_PM `ID` ) OUT( __pm_addr_pipe_r `E1` )


      source code reference for conflict
      [load_store.n:127] pm_addr_pipe `ID` = ag1p `ID`;
        <>
      [ocd_if.n:44] pm_addr_pipe `ID` = ocd_addr_r `ID` = ocd_addr `ID`;


      (refined) source code reference for conflict
      [load_store.n:127] pm_addr_pipe `ID` = ag1p `ID`
        <>
      [ocd_if.n:44] pm_addr_pipe `ID` = ocd_addr_r `ID` = ocd_addr `ID`

